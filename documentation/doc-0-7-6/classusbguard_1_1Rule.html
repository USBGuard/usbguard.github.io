<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>USBGuard: usbguard::Rule Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="usbguard-logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">USBGuard
   </div>
   <div id="projectbrief">Software framework that protects your computer against rogue USB devices by implementing basic whitelisting and blacklisting capabilities.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>usbguard</b></li><li class="navelem"><a class="el" href="classusbguard_1_1Rule.html">Rule</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classusbguard_1_1Rule-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">usbguard::Rule Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Determines whether USB device mathing specified criteria should be authorized, deauthorized or removed.  
 <a href="classusbguard_1_1Rule.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Rule_8hpp_source.html">Rule.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Attribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies which devices to match or what condition have to be met for the rule to be aplicable.  <a href="classusbguard_1_1Rule_1_1Attribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a99589e901823bb3e0c1ca50d83e256fc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fc">Target</a> { <br />
&#160;&#160;<a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fca45f0fb72a0defdfdb01de4b5a5a6876b">Target::Allow</a> = 0, 
<a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fcae1e4c8c9ccd9fc39c391da4bcd093fb2">Target::Block</a> = 1, 
<a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fcad98ac12774fca5c3cbaffe276840c55f">Target::Reject</a> = 2, 
<a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fca6da89265a9a8b0b28eb4946bb2ec0c6d">Target::Match</a> = 3, 
<br />
&#160;&#160;<a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fca88183b946cc5f0e8c96b2e66e1c74a7e">Target::Unknown</a> = 4, 
<a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fcae0ac20adce6ffee48c7151b070aa5737">Target::Device</a> = 5, 
<a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fcace2c8aed9c2fa0cfbed56cbda4d8bf07">Target::Empty</a> = 6, 
<a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fca4bbb8f967da6d1a610596d7257179c2b">Target::Invalid</a> = 7
<br />
 }</td></tr>
<tr class="memdesc:a99589e901823bb3e0c1ca50d83e256fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of possible rule targets.  <a href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fc">More...</a><br /></td></tr>
<tr class="separator:a99589e901823bb3e0c1ca50d83e256fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b949622369234b348c7f4d4e91ebc1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#a54b949622369234b348c7f4d4e91ebc1">SetOperator</a> { <br />
&#160;&#160;<a class="el" href="classusbguard_1_1Rule.html#a54b949622369234b348c7f4d4e91ebc1ac5fc8c53f043d5df43f4c3e2c00805a1">SetOperator::AllOf</a>, 
<a class="el" href="classusbguard_1_1Rule.html#a54b949622369234b348c7f4d4e91ebc1a104632c63520385967d8e185f7aa68dc">SetOperator::OneOf</a>, 
<a class="el" href="classusbguard_1_1Rule.html#a54b949622369234b348c7f4d4e91ebc1a2a0ead6be5565efd94b84baf575f3bf2">SetOperator::NoneOf</a>, 
<a class="el" href="classusbguard_1_1Rule.html#a54b949622369234b348c7f4d4e91ebc1a0ccb67e7eaae09d9e4078d161eeca100">SetOperator::Equals</a>, 
<br />
&#160;&#160;<a class="el" href="classusbguard_1_1Rule.html#a54b949622369234b348c7f4d4e91ebc1ae7606a207c18beaaaf218b62451788dc">SetOperator::EqualsOrdered</a>, 
<a class="el" href="classusbguard_1_1Rule.html#a54b949622369234b348c7f4d4e91ebc1a6da89265a9a8b0b28eb4946bb2ec0c6d">SetOperator::Match</a>
<br />
 }</td></tr>
<tr class="memdesc:a54b949622369234b348c7f4d4e91ebc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines set operators that can be used in the rules.  <a href="classusbguard_1_1Rule.html#a54b949622369234b348c7f4d4e91ebc1">More...</a><br /></td></tr>
<tr class="separator:a54b949622369234b348c7f4d4e91ebc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9516ee25ab487cd23d0c65827317cbcb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#a9516ee25ab487cd23d0c65827317cbcb">Rule</a> ()</td></tr>
<tr class="memdesc:a9516ee25ab487cd23d0c65827317cbcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a default rule.  <a href="#a9516ee25ab487cd23d0c65827317cbcb">More...</a><br /></td></tr>
<tr class="separator:a9516ee25ab487cd23d0c65827317cbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14cbe6c2a0e725281d995c60d3e7660a"><td class="memItemLeft" align="right" valign="top"><a id="a14cbe6c2a0e725281d995c60d3e7660a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#a14cbe6c2a0e725281d995c60d3e7660a">~Rule</a> ()</td></tr>
<tr class="memdesc:a14cbe6c2a0e725281d995c60d3e7660a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor. <br /></td></tr>
<tr class="separator:a14cbe6c2a0e725281d995c60d3e7660a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18714caf94e44295cec31f6c116ac76"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#ab18714caf94e44295cec31f6c116ac76">Rule</a> (const <a class="el" href="classusbguard_1_1Rule.html">Rule</a> &amp;rhs)</td></tr>
<tr class="memdesc:ab18714caf94e44295cec31f6c116ac76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs rule based on rhs.  <a href="#ab18714caf94e44295cec31f6c116ac76">More...</a><br /></td></tr>
<tr class="separator:ab18714caf94e44295cec31f6c116ac76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f4eb9adc6c8e44092ab00cc0a2fbfd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classusbguard_1_1Rule.html">Rule</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#a58f4eb9adc6c8e44092ab00cc0a2fbfd">operator=</a> (const <a class="el" href="classusbguard_1_1Rule.html">Rule</a> &amp;rhs)</td></tr>
<tr class="memdesc:a58f4eb9adc6c8e44092ab00cc0a2fbfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignes rhs rule to this.  <a href="#a58f4eb9adc6c8e44092ab00cc0a2fbfd">More...</a><br /></td></tr>
<tr class="separator:a58f4eb9adc6c8e44092ab00cc0a2fbfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c4553af8b30fdf39aaa54a8c450373"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#a58c4553af8b30fdf39aaa54a8c450373">setRuleID</a> (uint32_t rule_id)</td></tr>
<tr class="memdesc:a58c4553af8b30fdf39aaa54a8c450373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets rule ID.  <a href="#a58c4553af8b30fdf39aaa54a8c450373">More...</a><br /></td></tr>
<tr class="separator:a58c4553af8b30fdf39aaa54a8c450373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ab651bcfa712825f3e27fcd3e70098"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#a64ab651bcfa712825f3e27fcd3e70098">getRuleID</a> () const</td></tr>
<tr class="memdesc:a64ab651bcfa712825f3e27fcd3e70098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns rule ID.  <a href="#a64ab651bcfa712825f3e27fcd3e70098">More...</a><br /></td></tr>
<tr class="separator:a64ab651bcfa712825f3e27fcd3e70098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13510a25773e4bbabe2b6e9f78e39f79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#a13510a25773e4bbabe2b6e9f78e39f79">setTarget</a> (<a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fc">Rule::Target</a> target)</td></tr>
<tr class="memdesc:a13510a25773e4bbabe2b6e9f78e39f79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets rule target.  <a href="#a13510a25773e4bbabe2b6e9f78e39f79">More...</a><br /></td></tr>
<tr class="separator:a13510a25773e4bbabe2b6e9f78e39f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74066315ec93a4d6a1a361f46078874"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fc">Target</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#ae74066315ec93a4d6a1a361f46078874">getTarget</a> () const</td></tr>
<tr class="memdesc:ae74066315ec93a4d6a1a361f46078874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns rule target.  <a href="#ae74066315ec93a4d6a1a361f46078874">More...</a><br /></td></tr>
<tr class="separator:ae74066315ec93a4d6a1a361f46078874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3191f0c3dc572cbc96b0685164c27ef3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#a3191f0c3dc572cbc96b0685164c27ef3">setDeviceID</a> (const <a class="el" href="classusbguard_1_1USBDeviceID.html">USBDeviceID</a> &amp;value)</td></tr>
<tr class="memdesc:a3191f0c3dc572cbc96b0685164c27ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets USB Device ID attribute.  <a href="#a3191f0c3dc572cbc96b0685164c27ef3">More...</a><br /></td></tr>
<tr class="separator:a3191f0c3dc572cbc96b0685164c27ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2fcd0c3c54cc7edea2c7bc13b55638"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classusbguard_1_1USBDeviceID.html">USBDeviceID</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#a8d2fcd0c3c54cc7edea2c7bc13b55638">getDeviceID</a> () const</td></tr>
<tr class="memdesc:a8d2fcd0c3c54cc7edea2c7bc13b55638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns USB device ID.  <a href="#a8d2fcd0c3c54cc7edea2c7bc13b55638">More...</a><br /></td></tr>
<tr class="separator:a8d2fcd0c3c54cc7edea2c7bc13b55638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeddd941ae8e3481a14a88471e06380d2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Attribute</a>&lt; <a class="el" href="classusbguard_1_1USBDeviceID.html">USBDeviceID</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#aeddd941ae8e3481a14a88471e06380d2">attributeDeviceID</a> () const</td></tr>
<tr class="memdesc:aeddd941ae8e3481a14a88471e06380d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns imutable USB device ID attribute.  <a href="#aeddd941ae8e3481a14a88471e06380d2">More...</a><br /></td></tr>
<tr class="separator:aeddd941ae8e3481a14a88471e06380d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af770d76314301f7478e981d9614f9705"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Attribute</a>&lt; <a class="el" href="classusbguard_1_1USBDeviceID.html">USBDeviceID</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#af770d76314301f7478e981d9614f9705">attributeDeviceID</a> ()</td></tr>
<tr class="memdesc:af770d76314301f7478e981d9614f9705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns mutable USB device ID attribute.  <a href="#af770d76314301f7478e981d9614f9705">More...</a><br /></td></tr>
<tr class="separator:af770d76314301f7478e981d9614f9705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214ca4fdf7b33c9ee32641c73085fb1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#a214ca4fdf7b33c9ee32641c73085fb1e">setSerial</a> (const std::string &amp;value)</td></tr>
<tr class="memdesc:a214ca4fdf7b33c9ee32641c73085fb1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets serial number attribute.  <a href="#a214ca4fdf7b33c9ee32641c73085fb1e">More...</a><br /></td></tr>
<tr class="separator:a214ca4fdf7b33c9ee32641c73085fb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e7c180cbdfbd3a8065dbea53eadfb4"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#ae5e7c180cbdfbd3a8065dbea53eadfb4">getSerial</a> () const</td></tr>
<tr class="memdesc:ae5e7c180cbdfbd3a8065dbea53eadfb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns serial number.  <a href="#ae5e7c180cbdfbd3a8065dbea53eadfb4">More...</a><br /></td></tr>
<tr class="separator:ae5e7c180cbdfbd3a8065dbea53eadfb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0e89d33a8fd284b336b2d0d888bb37"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Attribute</a>&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#a3d0e89d33a8fd284b336b2d0d888bb37">attributeSerial</a> () const</td></tr>
<tr class="memdesc:a3d0e89d33a8fd284b336b2d0d888bb37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns imutable serial number attribute.  <a href="#a3d0e89d33a8fd284b336b2d0d888bb37">More...</a><br /></td></tr>
<tr class="separator:a3d0e89d33a8fd284b336b2d0d888bb37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac862588d20d241a01a8e5b9847b16138"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Attribute</a>&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#ac862588d20d241a01a8e5b9847b16138">attributeSerial</a> ()</td></tr>
<tr class="memdesc:ac862588d20d241a01a8e5b9847b16138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns mutable serial number attribute.  <a href="#ac862588d20d241a01a8e5b9847b16138">More...</a><br /></td></tr>
<tr class="separator:ac862588d20d241a01a8e5b9847b16138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa56ad2cc37a53a6963cc63f99672789b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#aa56ad2cc37a53a6963cc63f99672789b">setLabel</a> (const std::string &amp;value)</td></tr>
<tr class="memdesc:aa56ad2cc37a53a6963cc63f99672789b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets rule label attribute.  <a href="#aa56ad2cc37a53a6963cc63f99672789b">More...</a><br /></td></tr>
<tr class="separator:aa56ad2cc37a53a6963cc63f99672789b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e2ff74830360663c53c53ac77eb5d8"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#a76e2ff74830360663c53c53ac77eb5d8">getLabel</a> () const</td></tr>
<tr class="memdesc:a76e2ff74830360663c53c53ac77eb5d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns rule label.  <a href="#a76e2ff74830360663c53c53ac77eb5d8">More...</a><br /></td></tr>
<tr class="separator:a76e2ff74830360663c53c53ac77eb5d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adffcba777b0341bcdf10febef89333e4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Attribute</a>&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#adffcba777b0341bcdf10febef89333e4">attributeLabel</a> () const</td></tr>
<tr class="memdesc:adffcba777b0341bcdf10febef89333e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns imutable rule label attribute.  <a href="#adffcba777b0341bcdf10febef89333e4">More...</a><br /></td></tr>
<tr class="separator:adffcba777b0341bcdf10febef89333e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf920fcf09af0a264bce27b0f71fbc51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Attribute</a>&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#aaf920fcf09af0a264bce27b0f71fbc51">attributeLabel</a> ()</td></tr>
<tr class="memdesc:aaf920fcf09af0a264bce27b0f71fbc51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns mutable rule label attribute.  <a href="#aaf920fcf09af0a264bce27b0f71fbc51">More...</a><br /></td></tr>
<tr class="separator:aaf920fcf09af0a264bce27b0f71fbc51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133e49e3be809f0376e83cd2fc45e8f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#a133e49e3be809f0376e83cd2fc45e8f0">setWithConnectType</a> (const std::string &amp;value)</td></tr>
<tr class="memdesc:a133e49e3be809f0376e83cd2fc45e8f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets with-connect-type attribute.  <a href="#a133e49e3be809f0376e83cd2fc45e8f0">More...</a><br /></td></tr>
<tr class="separator:a133e49e3be809f0376e83cd2fc45e8f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ff4c50beb0965251289c1e330a920b"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#ac2ff4c50beb0965251289c1e330a920b">getWithConnectType</a> () const</td></tr>
<tr class="memdesc:ac2ff4c50beb0965251289c1e330a920b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns type of conncetion USB device uses.  <a href="#ac2ff4c50beb0965251289c1e330a920b">More...</a><br /></td></tr>
<tr class="separator:ac2ff4c50beb0965251289c1e330a920b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7163a25cb02ed34dc99fbf8c318a951c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Attribute</a>&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#a7163a25cb02ed34dc99fbf8c318a951c">attributeWithConnectType</a> () const</td></tr>
<tr class="memdesc:a7163a25cb02ed34dc99fbf8c318a951c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns imutable with-connect-type attribute.  <a href="#a7163a25cb02ed34dc99fbf8c318a951c">More...</a><br /></td></tr>
<tr class="separator:a7163a25cb02ed34dc99fbf8c318a951c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b34408c10c4c272ee02950d16da467"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Attribute</a>&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#a07b34408c10c4c272ee02950d16da467">attributeWithConnectType</a> ()</td></tr>
<tr class="memdesc:a07b34408c10c4c272ee02950d16da467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns mutable with-connect-type attribute.  <a href="#a07b34408c10c4c272ee02950d16da467">More...</a><br /></td></tr>
<tr class="separator:a07b34408c10c4c272ee02950d16da467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6f3166d7b63cc51a37a1fdff39d3b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#a4b6f3166d7b63cc51a37a1fdff39d3b3">setName</a> (const std::string &amp;value)</td></tr>
<tr class="memdesc:a4b6f3166d7b63cc51a37a1fdff39d3b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets device name attribute.  <a href="#a4b6f3166d7b63cc51a37a1fdff39d3b3">More...</a><br /></td></tr>
<tr class="separator:a4b6f3166d7b63cc51a37a1fdff39d3b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545d30ce94047fc8c9f95268f708b1eb"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#a545d30ce94047fc8c9f95268f708b1eb">getName</a> () const</td></tr>
<tr class="memdesc:a545d30ce94047fc8c9f95268f708b1eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns device name.  <a href="#a545d30ce94047fc8c9f95268f708b1eb">More...</a><br /></td></tr>
<tr class="separator:a545d30ce94047fc8c9f95268f708b1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8fab95432863481f7165e5c2d5ab243"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Attribute</a>&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#ab8fab95432863481f7165e5c2d5ab243">attributeName</a> () const</td></tr>
<tr class="memdesc:ab8fab95432863481f7165e5c2d5ab243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns imutable device name attribute.  <a href="#ab8fab95432863481f7165e5c2d5ab243">More...</a><br /></td></tr>
<tr class="separator:ab8fab95432863481f7165e5c2d5ab243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbc50aed613bfe1b7f363a37f716124"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Attribute</a>&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#afbbc50aed613bfe1b7f363a37f716124">attributeName</a> ()</td></tr>
<tr class="memdesc:afbbc50aed613bfe1b7f363a37f716124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns mutable device name attribute.  <a href="#afbbc50aed613bfe1b7f363a37f716124">More...</a><br /></td></tr>
<tr class="separator:afbbc50aed613bfe1b7f363a37f716124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2def4a0a74c42a03e35f1042e0c2ba9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#ad2def4a0a74c42a03e35f1042e0c2ba9">setHash</a> (const std::string &amp;value)</td></tr>
<tr class="memdesc:ad2def4a0a74c42a03e35f1042e0c2ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets device hash attribute.  <a href="#ad2def4a0a74c42a03e35f1042e0c2ba9">More...</a><br /></td></tr>
<tr class="separator:ad2def4a0a74c42a03e35f1042e0c2ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98e757a278d7451565f8c9e937dc0b5"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#ad98e757a278d7451565f8c9e937dc0b5">getHash</a> () const</td></tr>
<tr class="memdesc:ad98e757a278d7451565f8c9e937dc0b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns device hash.  <a href="#ad98e757a278d7451565f8c9e937dc0b5">More...</a><br /></td></tr>
<tr class="separator:ad98e757a278d7451565f8c9e937dc0b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82ad1b50a7143e7e28f92cfd4405c72b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Attribute</a>&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#a82ad1b50a7143e7e28f92cfd4405c72b">attributeHash</a> () const</td></tr>
<tr class="memdesc:a82ad1b50a7143e7e28f92cfd4405c72b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns imutable device hash attribute.  <a href="#a82ad1b50a7143e7e28f92cfd4405c72b">More...</a><br /></td></tr>
<tr class="separator:a82ad1b50a7143e7e28f92cfd4405c72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef8b7fc3a277c9609de0cab4b72913e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Attribute</a>&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#acef8b7fc3a277c9609de0cab4b72913e">attributeHash</a> ()</td></tr>
<tr class="memdesc:acef8b7fc3a277c9609de0cab4b72913e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns mutable device hash attribute.  <a href="#acef8b7fc3a277c9609de0cab4b72913e">More...</a><br /></td></tr>
<tr class="separator:acef8b7fc3a277c9609de0cab4b72913e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ff825c0f2444046cb6036ea952df62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#a57ff825c0f2444046cb6036ea952df62">setParentHash</a> (const std::string &amp;value)</td></tr>
<tr class="memdesc:a57ff825c0f2444046cb6036ea952df62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets parent hash attribute.  <a href="#a57ff825c0f2444046cb6036ea952df62">More...</a><br /></td></tr>
<tr class="separator:a57ff825c0f2444046cb6036ea952df62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa12265d35c3bc4805f02f1bbee5dd81"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#aaa12265d35c3bc4805f02f1bbee5dd81">getParentHash</a> () const</td></tr>
<tr class="memdesc:aaa12265d35c3bc4805f02f1bbee5dd81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns parent hash.  <a href="#aaa12265d35c3bc4805f02f1bbee5dd81">More...</a><br /></td></tr>
<tr class="separator:aaa12265d35c3bc4805f02f1bbee5dd81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca7ebe7488776930d3c021867f86e5d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Rule::Attribute</a>&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#acca7ebe7488776930d3c021867f86e5d">attributeParentHash</a> () const</td></tr>
<tr class="memdesc:acca7ebe7488776930d3c021867f86e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns imutable parent hash attribute.  <a href="#acca7ebe7488776930d3c021867f86e5d">More...</a><br /></td></tr>
<tr class="separator:acca7ebe7488776930d3c021867f86e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b457b0b6009dc85de11f979b2f60c8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Rule::Attribute</a>&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#a4b457b0b6009dc85de11f979b2f60c8b">attributeParentHash</a> ()</td></tr>
<tr class="memdesc:a4b457b0b6009dc85de11f979b2f60c8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns mutable parent hash attribute.  <a href="#a4b457b0b6009dc85de11f979b2f60c8b">More...</a><br /></td></tr>
<tr class="separator:a4b457b0b6009dc85de11f979b2f60c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b124dbe9809a0b608567eb8a8dc923d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#a9b124dbe9809a0b608567eb8a8dc923d">setViaPort</a> (const std::string &amp;value)</td></tr>
<tr class="memdesc:a9b124dbe9809a0b608567eb8a8dc923d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets via-port attribute.  <a href="#a9b124dbe9809a0b608567eb8a8dc923d">More...</a><br /></td></tr>
<tr class="separator:a9b124dbe9809a0b608567eb8a8dc923d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74f8ceab1c0d691bcc6dd1d681fe5e6"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#ac74f8ceab1c0d691bcc6dd1d681fe5e6">getViaPort</a> () const</td></tr>
<tr class="memdesc:ac74f8ceab1c0d691bcc6dd1d681fe5e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns USB port through which the device is connected.  <a href="#ac74f8ceab1c0d691bcc6dd1d681fe5e6">More...</a><br /></td></tr>
<tr class="separator:ac74f8ceab1c0d691bcc6dd1d681fe5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1fffbe57f6f0f269cafec04870e693"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Attribute</a>&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#afc1fffbe57f6f0f269cafec04870e693">attributeViaPort</a> () const</td></tr>
<tr class="memdesc:afc1fffbe57f6f0f269cafec04870e693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns imutable via-port attribute.  <a href="#afc1fffbe57f6f0f269cafec04870e693">More...</a><br /></td></tr>
<tr class="separator:afc1fffbe57f6f0f269cafec04870e693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57bdfa45793faefededda932e19d026"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Attribute</a>&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#ad57bdfa45793faefededda932e19d026">attributeViaPort</a> ()</td></tr>
<tr class="memdesc:ad57bdfa45793faefededda932e19d026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns mutable via-port attribute.  <a href="#ad57bdfa45793faefededda932e19d026">More...</a><br /></td></tr>
<tr class="separator:ad57bdfa45793faefededda932e19d026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671a40b1fbf124ee9ffcbe37d9ab5aaf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Attribute</a>&lt; <a class="el" href="classusbguard_1_1USBInterfaceType.html">USBInterfaceType</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#a671a40b1fbf124ee9ffcbe37d9ab5aaf">attributeWithInterface</a> () const</td></tr>
<tr class="memdesc:a671a40b1fbf124ee9ffcbe37d9ab5aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns imutable with-interface attribute.  <a href="#a671a40b1fbf124ee9ffcbe37d9ab5aaf">More...</a><br /></td></tr>
<tr class="separator:a671a40b1fbf124ee9ffcbe37d9ab5aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6dd8ff562d72f637fcb228695080bf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Attribute</a>&lt; <a class="el" href="classusbguard_1_1USBInterfaceType.html">USBInterfaceType</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#af6dd8ff562d72f637fcb228695080bf5">attributeWithInterface</a> ()</td></tr>
<tr class="memdesc:af6dd8ff562d72f637fcb228695080bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns mutable with-interface attribute.  <a href="#af6dd8ff562d72f637fcb228695080bf5">More...</a><br /></td></tr>
<tr class="separator:af6dd8ff562d72f637fcb228695080bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ca9f45e3a560a6cf7b549d88f1a5f3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Attribute</a>&lt; <a class="el" href="classusbguard_1_1RuleCondition.html">RuleCondition</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#a10ca9f45e3a560a6cf7b549d88f1a5f3">attributeConditions</a> () const</td></tr>
<tr class="memdesc:a10ca9f45e3a560a6cf7b549d88f1a5f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns imutable rule conditions attribute.  <a href="#a10ca9f45e3a560a6cf7b549d88f1a5f3">More...</a><br /></td></tr>
<tr class="separator:a10ca9f45e3a560a6cf7b549d88f1a5f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a81a611c0073bac6492a03a100f94b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Attribute</a>&lt; <a class="el" href="classusbguard_1_1RuleCondition.html">RuleCondition</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#a9a81a611c0073bac6492a03a100f94b8">attributeConditions</a> ()</td></tr>
<tr class="memdesc:a9a81a611c0073bac6492a03a100f94b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns mutable rule conditions attribute.  <a href="#a9a81a611c0073bac6492a03a100f94b8">More...</a><br /></td></tr>
<tr class="separator:a9a81a611c0073bac6492a03a100f94b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b09ce21f8a27a10a4f2987ec015a94"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#aa3b09ce21f8a27a10a4f2987ec015a94">appliesTo</a> (std::shared_ptr&lt; const <a class="el" href="classusbguard_1_1Rule.html">Rule</a> &gt; rhs) const</td></tr>
<tr class="memdesc:aa3b09ce21f8a27a10a4f2987ec015a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether this rule applies to rhs rule.  <a href="#aa3b09ce21f8a27a10a4f2987ec015a94">More...</a><br /></td></tr>
<tr class="separator:aa3b09ce21f8a27a10a4f2987ec015a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab153ed5c6a01692e3e86020c0bef8977"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#ab153ed5c6a01692e3e86020c0bef8977">appliesTo</a> (const <a class="el" href="classusbguard_1_1Rule.html">Rule</a> &amp;rhs) const</td></tr>
<tr class="memdesc:ab153ed5c6a01692e3e86020c0bef8977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether this rule applies to rhs rule.  <a href="#ab153ed5c6a01692e3e86020c0bef8977">More...</a><br /></td></tr>
<tr class="separator:ab153ed5c6a01692e3e86020c0bef8977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df7ba1f77fc6792205ce6cf96f28a63"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#a4df7ba1f77fc6792205ce6cf96f28a63">appliesTo</a> (const <a class="el" href="classusbguard_1_1Rule.html">Rule</a> &amp;rhs)</td></tr>
<tr class="memdesc:a4df7ba1f77fc6792205ce6cf96f28a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether this rule applies to rhs rule and updates last evaluated meta-data counter.  <a href="#a4df7ba1f77fc6792205ce6cf96f28a63">More...</a><br /></td></tr>
<tr class="separator:a4df7ba1f77fc6792205ce6cf96f28a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2156844e376b882355bbfa6c82e0ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#a6b2156844e376b882355bbfa6c82e0ec">isImplicit</a> () const</td></tr>
<tr class="memdesc:a6b2156844e376b882355bbfa6c82e0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the rule is implicit (rule has default rule ID).  <a href="#a6b2156844e376b882355bbfa6c82e0ec">More...</a><br /></td></tr>
<tr class="separator:a6b2156844e376b882355bbfa6c82e0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6731a4b3098e2410bf0096f33dfbed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#a6e6731a4b3098e2410bf0096f33dfbed">operator bool</a> () const</td></tr>
<tr class="memdesc:a6e6731a4b3098e2410bf0096f33dfbed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if rule target is neither unknown nor invalid nor empty.  <a href="#a6e6731a4b3098e2410bf0096f33dfbed">More...</a><br /></td></tr>
<tr class="separator:a6e6731a4b3098e2410bf0096f33dfbed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45b1cd9c6e0b7a61cb3aad0dfccaf56"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#ab45b1cd9c6e0b7a61cb3aad0dfccaf56">toString</a> (bool invalid=false, bool hide_serial=false) const</td></tr>
<tr class="memdesc:ab45b1cd9c6e0b7a61cb3aad0dfccaf56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns string representation of this rule.  <a href="#ab45b1cd9c6e0b7a61cb3aad0dfccaf56">More...</a><br /></td></tr>
<tr class="separator:ab45b1cd9c6e0b7a61cb3aad0dfccaf56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46cb2e10e705921d6f10162b33816565"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#a46cb2e10e705921d6f10162b33816565">updateMetaDataCounters</a> (bool applied=true, bool evaluated=false)</td></tr>
<tr class="memdesc:a46cb2e10e705921d6f10162b33816565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates meta-data last applied and last evaluated counters.  <a href="#a46cb2e10e705921d6f10162b33816565">More...</a><br /></td></tr>
<tr class="separator:a46cb2e10e705921d6f10162b33816565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd2bc1a0181d0e4815ee763507952de"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; RulePrivate &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#a9bd2bc1a0181d0e4815ee763507952de">internal</a> ()</td></tr>
<tr class="memdesc:a9bd2bc1a0181d0e4815ee763507952de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to mutable RulePrivate object of this rule.  <a href="#a9bd2bc1a0181d0e4815ee763507952de">More...</a><br /></td></tr>
<tr class="separator:a9bd2bc1a0181d0e4815ee763507952de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d40817a748dbad90a4fb9d5ee8e17b2"><td class="memItemLeft" align="right" valign="top">const std::unique_ptr&lt; RulePrivate &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#a6d40817a748dbad90a4fb9d5ee8e17b2">internal</a> () const</td></tr>
<tr class="memdesc:a6d40817a748dbad90a4fb9d5ee8e17b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to imutable RulePrivate object of this rule.  <a href="#a6d40817a748dbad90a4fb9d5ee8e17b2">More...</a><br /></td></tr>
<tr class="separator:a6d40817a748dbad90a4fb9d5ee8e17b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a916bd83c392e0b7f17cfd885f547ffea"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#a916bd83c392e0b7f17cfd885f547ffea">targetToString</a> (<a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fc">Target</a> target)</td></tr>
<tr class="memdesc:a916bd83c392e0b7f17cfd885f547ffea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts given rule target to its string representation.  <a href="#a916bd83c392e0b7f17cfd885f547ffea">More...</a><br /></td></tr>
<tr class="separator:a916bd83c392e0b7f17cfd885f547ffea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ef58acc9cf41bc9a0504cdd7663d2c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fc">Target</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#a29ef58acc9cf41bc9a0504cdd7663d2c">targetFromString</a> (const std::string &amp;target_string)</td></tr>
<tr class="memdesc:a29ef58acc9cf41bc9a0504cdd7663d2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts given string into rule target.  <a href="#a29ef58acc9cf41bc9a0504cdd7663d2c">More...</a><br /></td></tr>
<tr class="separator:a29ef58acc9cf41bc9a0504cdd7663d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1dcb2b31383e8e036eda68e2073d559"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#ad1dcb2b31383e8e036eda68e2073d559">targetToInteger</a> (<a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fc">Target</a> target)</td></tr>
<tr class="memdesc:ad1dcb2b31383e8e036eda68e2073d559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts rule target to its integer representation.  <a href="#ad1dcb2b31383e8e036eda68e2073d559">More...</a><br /></td></tr>
<tr class="separator:ad1dcb2b31383e8e036eda68e2073d559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513bf91b5bc68416d42b59cf9140fccc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fc">Target</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#a513bf91b5bc68416d42b59cf9140fccc">targetFromInteger</a> (uint32_t target_integer)</td></tr>
<tr class="memdesc:a513bf91b5bc68416d42b59cf9140fccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts integer into rule target.  <a href="#a513bf91b5bc68416d42b59cf9140fccc">More...</a><br /></td></tr>
<tr class="separator:a513bf91b5bc68416d42b59cf9140fccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a235f36bd67b5567a8981dfe6f24f48"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#a4a235f36bd67b5567a8981dfe6f24f48">setOperatorToString</a> (const <a class="el" href="classusbguard_1_1Rule.html#a54b949622369234b348c7f4d4e91ebc1">Rule::SetOperator</a> &amp;op)</td></tr>
<tr class="memdesc:a4a235f36bd67b5567a8981dfe6f24f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts given set operator to its string representation.  <a href="#a4a235f36bd67b5567a8981dfe6f24f48">More...</a><br /></td></tr>
<tr class="separator:a4a235f36bd67b5567a8981dfe6f24f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae177e4f146633274c8e5ff7ee8ef88"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classusbguard_1_1Rule.html#a54b949622369234b348c7f4d4e91ebc1">SetOperator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#a1ae177e4f146633274c8e5ff7ee8ef88">setOperatorFromString</a> (const std::string &amp;set_operator_string)</td></tr>
<tr class="memdesc:a1ae177e4f146633274c8e5ff7ee8ef88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts string into set operator.  <a href="#a1ae177e4f146633274c8e5ff7ee8ef88">More...</a><br /></td></tr>
<tr class="separator:a1ae177e4f146633274c8e5ff7ee8ef88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2d6782d186866e6ebdd87ab8879bb6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classusbguard_1_1Rule.html">Rule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#afa2d6782d186866e6ebdd87ab8879bb6">fromString</a> (const std::string &amp;rule_string)</td></tr>
<tr class="memdesc:afa2d6782d186866e6ebdd87ab8879bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses given rule_string and returns Rule object.  <a href="#afa2d6782d186866e6ebdd87ab8879bb6">More...</a><br /></td></tr>
<tr class="separator:afa2d6782d186866e6ebdd87ab8879bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a726fae0a339a50631a1a2b80e92301b3"><td class="memItemLeft" align="right" valign="top"><a id="a726fae0a339a50631a1a2b80e92301b3"></a>
static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#a726fae0a339a50631a1a2b80e92301b3">RootID</a> = std::numeric_limits&lt;uint32_t&gt;::min()</td></tr>
<tr class="memdesc:a726fae0a339a50631a1a2b80e92301b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence number of the (fake) root rule. <br /></td></tr>
<tr class="separator:a726fae0a339a50631a1a2b80e92301b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850e2d86d9cba0d96c4006b0ce3258d9"><td class="memItemLeft" align="right" valign="top"><a id="a850e2d86d9cba0d96c4006b0ce3258d9"></a>
static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#a850e2d86d9cba0d96c4006b0ce3258d9">DefaultID</a> = std::numeric_limits&lt;uint32_t&gt;::max()</td></tr>
<tr class="memdesc:a850e2d86d9cba0d96c4006b0ce3258d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence number assigned to default constructed rules. Cannot be used for searching. <br /></td></tr>
<tr class="separator:a850e2d86d9cba0d96c4006b0ce3258d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0401bd0ae7a6d555bd3e8d2a787b7dda"><td class="memItemLeft" align="right" valign="top"><a id="a0401bd0ae7a6d555bd3e8d2a787b7dda"></a>
static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#a0401bd0ae7a6d555bd3e8d2a787b7dda">LastID</a> = std::numeric_limits&lt;uint32_t&gt;::max() - 2</td></tr>
<tr class="memdesc:a0401bd0ae7a6d555bd3e8d2a787b7dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence number for specifying that the last rule in the ruleset should be used in context of the operation. <br /></td></tr>
<tr class="separator:a0401bd0ae7a6d555bd3e8d2a787b7dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9436dd1e9fb1d11a706b297f70245474"><td class="memItemLeft" align="right" valign="top"><a id="a9436dd1e9fb1d11a706b297f70245474"></a>
static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Rule.html#a9436dd1e9fb1d11a706b297f70245474">ImplicitID</a> = std::numeric_limits&lt;uint32_t&gt;::max() - 1</td></tr>
<tr class="memdesc:a9436dd1e9fb1d11a706b297f70245474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence number of the implicit target rule. <br /></td></tr>
<tr class="separator:a9436dd1e9fb1d11a706b297f70245474"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Determines whether USB device mathing specified criteria should be authorized, deauthorized or removed. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a54b949622369234b348c7f4d4e91ebc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b949622369234b348c7f4d4e91ebc1">&#9670;&nbsp;</a></span>SetOperator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classusbguard_1_1Rule.html#a54b949622369234b348c7f4d4e91ebc1">usbguard::Rule::SetOperator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines set operators that can be used in the rules. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a54b949622369234b348c7f4d4e91ebc1ac5fc8c53f043d5df43f4c3e2c00805a1"></a>AllOf&#160;</td><td class="fielddoc"><p>The device attribute set must contain all of the specified values for the rule to match. </p>
</td></tr>
<tr><td class="fieldname"><a id="a54b949622369234b348c7f4d4e91ebc1a104632c63520385967d8e185f7aa68dc"></a>OneOf&#160;</td><td class="fielddoc"><p>The device attribute set must contain at least one of the specified values for the rule to match. </p>
</td></tr>
<tr><td class="fieldname"><a id="a54b949622369234b348c7f4d4e91ebc1a2a0ead6be5565efd94b84baf575f3bf2"></a>NoneOf&#160;</td><td class="fielddoc"><p>The device attribute set must not contain any of the specified values for the rule to match. </p>
</td></tr>
<tr><td class="fieldname"><a id="a54b949622369234b348c7f4d4e91ebc1a0ccb67e7eaae09d9e4078d161eeca100"></a>Equals&#160;</td><td class="fielddoc"><p>The device attribute set must contain exactly the same set of values for the rule to match. </p>
</td></tr>
<tr><td class="fieldname"><a id="a54b949622369234b348c7f4d4e91ebc1ae7606a207c18beaaaf218b62451788dc"></a>EqualsOrdered&#160;</td><td class="fielddoc"><p>The device attribute set must contain exactly the same set of values in the same order for the rule to match. </p>
</td></tr>
<tr><td class="fieldname"><a id="a54b949622369234b348c7f4d4e91ebc1a6da89265a9a8b0b28eb4946bb2ec0c6d"></a>Match&#160;</td><td class="fielddoc"><p>Special operator: matches anything, cannot be used directly in a rule. </p>
</td></tr>
</table>

</div>
</div>
<a id="a99589e901823bb3e0c1ca50d83e256fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99589e901823bb3e0c1ca50d83e256fc">&#9670;&nbsp;</a></span>Target</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fc">usbguard::Rule::Target</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of possible rule targets. </p>
<p>The target of a rule specifies whether the device will be authorized for use or not. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a99589e901823bb3e0c1ca50d83e256fca45f0fb72a0defdfdb01de4b5a5a6876b"></a>Allow&#160;</td><td class="fielddoc"><p>Devices matching this rule will be authorized. In other words, the device and its interface will be allowed to communicate with the system. </p>
</td></tr>
<tr><td class="fieldname"><a id="a99589e901823bb3e0c1ca50d83e256fcae1e4c8c9ccd9fc39c391da4bcd093fb2"></a>Block&#160;</td><td class="fielddoc"><p>Devices matching this rule will not be authorized. </p>
</td></tr>
<tr><td class="fieldname"><a id="a99589e901823bb3e0c1ca50d83e256fcad98ac12774fca5c3cbaffe276840c55f"></a>Reject&#160;</td><td class="fielddoc"><p>Devices matching this rule will not be authorized and will be detached. </p>
</td></tr>
<tr><td class="fieldname"><a id="a99589e901823bb3e0c1ca50d83e256fca6da89265a9a8b0b28eb4946bb2ec0c6d"></a>Match&#160;</td><td class="fielddoc"><p>Special target which can be used to trigger actions. The rule wont affect the final decision. </p>
</td></tr>
<tr><td class="fieldname"><a id="a99589e901823bb3e0c1ca50d83e256fca88183b946cc5f0e8c96b2e66e1c74a7e"></a>Unknown&#160;</td><td class="fielddoc"><p>Unknown target. Used for default constructed rules. </p>
</td></tr>
<tr><td class="fieldname"><a id="a99589e901823bb3e0c1ca50d83e256fcae0ac20adce6ffee48c7151b070aa5737"></a>Device&#160;</td><td class="fielddoc"><p>Special target which can only be used for a rule that represents a single device. </p>
</td></tr>
<tr><td class="fieldname"><a id="a99589e901823bb3e0c1ca50d83e256fcace2c8aed9c2fa0cfbed56cbda4d8bf07"></a>Empty&#160;</td><td class="fielddoc"><p>Special target to represent the case the parser reaches a comment only line. </p>
</td></tr>
<tr><td class="fieldname"><a id="a99589e901823bb3e0c1ca50d83e256fca4bbb8f967da6d1a610596d7257179c2b"></a>Invalid&#160;</td><td class="fielddoc"><p>Represents invalid target. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9516ee25ab487cd23d0c65827317cbcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9516ee25ab487cd23d0c65827317cbcb">&#9670;&nbsp;</a></span>Rule() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">usbguard::Rule::Rule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a default rule. </p>
<p>This rule matches only a default rule and cannot be converted to a string representation. </p>

</div>
</div>
<a id="ab18714caf94e44295cec31f6c116ac76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab18714caf94e44295cec31f6c116ac76">&#9670;&nbsp;</a></span>Rule() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">usbguard::Rule::Rule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classusbguard_1_1Rule.html">Rule</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs rule based on rhs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Rule to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa3b09ce21f8a27a10a4f2987ec015a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b09ce21f8a27a10a4f2987ec015a94">&#9670;&nbsp;</a></span>appliesTo() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool usbguard::Rule::appliesTo </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classusbguard_1_1Rule.html">Rule</a> &gt;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether this rule applies to rhs rule. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Rule to apply to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this rule applies to rhs rule, false otherwise. </dd></dl>

</div>
</div>
<a id="ab153ed5c6a01692e3e86020c0bef8977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab153ed5c6a01692e3e86020c0bef8977">&#9670;&nbsp;</a></span>appliesTo() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool usbguard::Rule::appliesTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classusbguard_1_1Rule.html">Rule</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether this rule applies to rhs rule. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Rule to apply to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this rule applies to rhs rule, false otherwise. </dd></dl>

</div>
</div>
<a id="a4df7ba1f77fc6792205ce6cf96f28a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4df7ba1f77fc6792205ce6cf96f28a63">&#9670;&nbsp;</a></span>appliesTo() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool usbguard::Rule::appliesTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classusbguard_1_1Rule.html">Rule</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether this rule applies to rhs rule and updates last evaluated meta-data counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Rule to apply to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this rule applies to rhs rule, false otherwise. </dd></dl>

</div>
</div>
<a id="a10ca9f45e3a560a6cf7b549d88f1a5f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10ca9f45e3a560a6cf7b549d88f1a5f3">&#9670;&nbsp;</a></span>attributeConditions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Rule::Attribute</a>&lt; <a class="el" href="classusbguard_1_1RuleCondition.html">RuleCondition</a> &gt; &amp; usbguard::Rule::attributeConditions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns imutable rule conditions attribute. </p>
<dl class="section return"><dt>Returns</dt><dd>Imutable rule conditions attribute. </dd></dl>

</div>
</div>
<a id="a9a81a611c0073bac6492a03a100f94b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a81a611c0073bac6492a03a100f94b8">&#9670;&nbsp;</a></span>attributeConditions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Rule::Attribute</a>&lt; <a class="el" href="classusbguard_1_1RuleCondition.html">RuleCondition</a> &gt; &amp; usbguard::Rule::attributeConditions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns mutable rule conditions attribute. </p>
<dl class="section return"><dt>Returns</dt><dd>Mutable rule conditions attribute. </dd></dl>

</div>
</div>
<a id="aeddd941ae8e3481a14a88471e06380d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeddd941ae8e3481a14a88471e06380d2">&#9670;&nbsp;</a></span>attributeDeviceID() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Rule::Attribute</a>&lt; <a class="el" href="classusbguard_1_1USBDeviceID.html">USBDeviceID</a> &gt; &amp; usbguard::Rule::attributeDeviceID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns imutable USB device ID attribute. </p>
<dl class="section return"><dt>Returns</dt><dd>Imutable USB device ID attribute. </dd></dl>

</div>
</div>
<a id="af770d76314301f7478e981d9614f9705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af770d76314301f7478e981d9614f9705">&#9670;&nbsp;</a></span>attributeDeviceID() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Rule::Attribute</a>&lt; <a class="el" href="classusbguard_1_1USBDeviceID.html">USBDeviceID</a> &gt; &amp; usbguard::Rule::attributeDeviceID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns mutable USB device ID attribute. </p>
<dl class="section return"><dt>Returns</dt><dd>Mutable USB device ID attribute. </dd></dl>

</div>
</div>
<a id="a82ad1b50a7143e7e28f92cfd4405c72b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82ad1b50a7143e7e28f92cfd4405c72b">&#9670;&nbsp;</a></span>attributeHash() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Rule::Attribute</a>&lt; std::string &gt; &amp; usbguard::Rule::attributeHash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns imutable device hash attribute. </p>
<dl class="section return"><dt>Returns</dt><dd>Imutable device hash attribute. </dd></dl>

</div>
</div>
<a id="acef8b7fc3a277c9609de0cab4b72913e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acef8b7fc3a277c9609de0cab4b72913e">&#9670;&nbsp;</a></span>attributeHash() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Rule::Attribute</a>&lt; std::string &gt; &amp; usbguard::Rule::attributeHash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns mutable device hash attribute. </p>
<dl class="section return"><dt>Returns</dt><dd>Mutable device hash attribute. </dd></dl>

</div>
</div>
<a id="adffcba777b0341bcdf10febef89333e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adffcba777b0341bcdf10febef89333e4">&#9670;&nbsp;</a></span>attributeLabel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Rule::Attribute</a>&lt; std::string &gt; &amp; usbguard::Rule::attributeLabel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns imutable rule label attribute. </p>
<dl class="section return"><dt>Returns</dt><dd>Imutable rule label attribute. </dd></dl>

</div>
</div>
<a id="aaf920fcf09af0a264bce27b0f71fbc51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf920fcf09af0a264bce27b0f71fbc51">&#9670;&nbsp;</a></span>attributeLabel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Rule::Attribute</a>&lt; std::string &gt; &amp; usbguard::Rule::attributeLabel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns mutable rule label attribute. </p>
<dl class="section return"><dt>Returns</dt><dd>Mutable rule label attribute. </dd></dl>

</div>
</div>
<a id="ab8fab95432863481f7165e5c2d5ab243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8fab95432863481f7165e5c2d5ab243">&#9670;&nbsp;</a></span>attributeName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Rule::Attribute</a>&lt; std::string &gt; &amp; usbguard::Rule::attributeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns imutable device name attribute. </p>
<dl class="section return"><dt>Returns</dt><dd>Imutable device name attribute. </dd></dl>

</div>
</div>
<a id="afbbc50aed613bfe1b7f363a37f716124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbbc50aed613bfe1b7f363a37f716124">&#9670;&nbsp;</a></span>attributeName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Rule::Attribute</a>&lt; std::string &gt; &amp; usbguard::Rule::attributeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns mutable device name attribute. </p>
<dl class="section return"><dt>Returns</dt><dd>Mutable device name attribute. </dd></dl>

</div>
</div>
<a id="acca7ebe7488776930d3c021867f86e5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca7ebe7488776930d3c021867f86e5d">&#9670;&nbsp;</a></span>attributeParentHash() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Rule::Attribute</a>&lt; std::string &gt; &amp; usbguard::Rule::attributeParentHash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns imutable parent hash attribute. </p>
<dl class="section return"><dt>Returns</dt><dd>Imutable parent hash attribute. </dd></dl>

</div>
</div>
<a id="a4b457b0b6009dc85de11f979b2f60c8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b457b0b6009dc85de11f979b2f60c8b">&#9670;&nbsp;</a></span>attributeParentHash() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Rule::Attribute</a>&lt; std::string &gt; &amp; usbguard::Rule::attributeParentHash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns mutable parent hash attribute. </p>
<dl class="section return"><dt>Returns</dt><dd>Mutable parent hash attribute. </dd></dl>

</div>
</div>
<a id="a3d0e89d33a8fd284b336b2d0d888bb37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d0e89d33a8fd284b336b2d0d888bb37">&#9670;&nbsp;</a></span>attributeSerial() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Rule::Attribute</a>&lt; std::string &gt; &amp; usbguard::Rule::attributeSerial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns imutable serial number attribute. </p>
<dl class="section return"><dt>Returns</dt><dd>Imutable serial number attribute. </dd></dl>

</div>
</div>
<a id="ac862588d20d241a01a8e5b9847b16138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac862588d20d241a01a8e5b9847b16138">&#9670;&nbsp;</a></span>attributeSerial() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Rule::Attribute</a>&lt; std::string &gt; &amp; usbguard::Rule::attributeSerial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns mutable serial number attribute. </p>
<dl class="section return"><dt>Returns</dt><dd>Mutable serial number attribute. </dd></dl>

</div>
</div>
<a id="afc1fffbe57f6f0f269cafec04870e693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1fffbe57f6f0f269cafec04870e693">&#9670;&nbsp;</a></span>attributeViaPort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Rule::Attribute</a>&lt; std::string &gt; &amp; usbguard::Rule::attributeViaPort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns imutable via-port attribute. </p>
<dl class="section return"><dt>Returns</dt><dd>Imutable via-port attribute. </dd></dl>

</div>
</div>
<a id="ad57bdfa45793faefededda932e19d026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad57bdfa45793faefededda932e19d026">&#9670;&nbsp;</a></span>attributeViaPort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Rule::Attribute</a>&lt; std::string &gt; &amp; usbguard::Rule::attributeViaPort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns mutable via-port attribute. </p>
<dl class="section return"><dt>Returns</dt><dd>Mutable via-port attribute. </dd></dl>

</div>
</div>
<a id="a7163a25cb02ed34dc99fbf8c318a951c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7163a25cb02ed34dc99fbf8c318a951c">&#9670;&nbsp;</a></span>attributeWithConnectType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Rule::Attribute</a>&lt; std::string &gt; &amp; usbguard::Rule::attributeWithConnectType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns imutable with-connect-type attribute. </p>
<dl class="section return"><dt>Returns</dt><dd>Imutable with-connect-type attribute. </dd></dl>

</div>
</div>
<a id="a07b34408c10c4c272ee02950d16da467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b34408c10c4c272ee02950d16da467">&#9670;&nbsp;</a></span>attributeWithConnectType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Rule::Attribute</a>&lt; std::string &gt; &amp; usbguard::Rule::attributeWithConnectType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns mutable with-connect-type attribute. </p>
<dl class="section return"><dt>Returns</dt><dd>Mutable with-connect-type attribute. </dd></dl>

</div>
</div>
<a id="a671a40b1fbf124ee9ffcbe37d9ab5aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a671a40b1fbf124ee9ffcbe37d9ab5aaf">&#9670;&nbsp;</a></span>attributeWithInterface() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Rule::Attribute</a>&lt; <a class="el" href="classusbguard_1_1USBInterfaceType.html">USBInterfaceType</a> &gt; &amp; usbguard::Rule::attributeWithInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns imutable with-interface attribute. </p>
<dl class="section note"><dt>Note</dt><dd>Set/get methods for a single value isn't useful for the with-interface attribute as it usually contains multiple values. Therefore, we provide only the attribute accessors in this case.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Imutable with-interface attribute. </dd></dl>

</div>
</div>
<a id="af6dd8ff562d72f637fcb228695080bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6dd8ff562d72f637fcb228695080bf5">&#9670;&nbsp;</a></span>attributeWithInterface() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classusbguard_1_1Rule_1_1Attribute.html">Rule::Attribute</a>&lt; <a class="el" href="classusbguard_1_1USBInterfaceType.html">USBInterfaceType</a> &gt; &amp; usbguard::Rule::attributeWithInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns mutable with-interface attribute. </p>
<dl class="section note"><dt>Note</dt><dd>Set/get methods for a single value isn't useful for the with-interface attribute as it usually contains multiple values. Therefore, we provide only the attribute accessors in this case.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Mutable with-interface attribute. </dd></dl>

</div>
</div>
<a id="afa2d6782d186866e6ebdd87ab8879bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa2d6782d186866e6ebdd87ab8879bb6">&#9670;&nbsp;</a></span>fromString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classusbguard_1_1Rule.html">Rule</a> usbguard::Rule::fromString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rule_string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses given rule_string and returns Rule object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rule_string</td><td>String to parse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Rule object from given rule_string. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="">parseRuleFromString()</a> </dd></dl>

</div>
</div>
<a id="a8d2fcd0c3c54cc7edea2c7bc13b55638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d2fcd0c3c54cc7edea2c7bc13b55638">&#9670;&nbsp;</a></span>getDeviceID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classusbguard_1_1USBDeviceID.html">USBDeviceID</a> &amp; usbguard::Rule::getDeviceID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns USB device ID. </p>
<dl class="section return"><dt>Returns</dt><dd>USB device ID. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusbguard_1_1Rule_1_1Attribute.html#a3a3c2b218c7b807d93e307e02bc14a74">get()</a> </dd></dl>

</div>
</div>
<a id="ad98e757a278d7451565f8c9e937dc0b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad98e757a278d7451565f8c9e937dc0b5">&#9670;&nbsp;</a></span>getHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; usbguard::Rule::getHash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns device hash. </p>
<dl class="section return"><dt>Returns</dt><dd>Device hash. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusbguard_1_1Rule_1_1Attribute.html#a3a3c2b218c7b807d93e307e02bc14a74">get()</a> </dd></dl>

</div>
</div>
<a id="a76e2ff74830360663c53c53ac77eb5d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76e2ff74830360663c53c53ac77eb5d8">&#9670;&nbsp;</a></span>getLabel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; usbguard::Rule::getLabel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns rule label. </p>
<dl class="section return"><dt>Returns</dt><dd>Rule label. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusbguard_1_1Rule_1_1Attribute.html#a3a3c2b218c7b807d93e307e02bc14a74">get()</a> </dd></dl>

</div>
</div>
<a id="a545d30ce94047fc8c9f95268f708b1eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a545d30ce94047fc8c9f95268f708b1eb">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; usbguard::Rule::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns device name. </p>
<dl class="section return"><dt>Returns</dt><dd>Device name. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusbguard_1_1Rule_1_1Attribute.html#a3a3c2b218c7b807d93e307e02bc14a74">get()</a> </dd></dl>

</div>
</div>
<a id="aaa12265d35c3bc4805f02f1bbee5dd81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa12265d35c3bc4805f02f1bbee5dd81">&#9670;&nbsp;</a></span>getParentHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; usbguard::Rule::getParentHash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns parent hash. </p>
<dl class="section return"><dt>Returns</dt><dd>Parent hash. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusbguard_1_1Rule_1_1Attribute.html#a3a3c2b218c7b807d93e307e02bc14a74">get()</a> </dd></dl>

</div>
</div>
<a id="a64ab651bcfa712825f3e27fcd3e70098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ab651bcfa712825f3e27fcd3e70098">&#9670;&nbsp;</a></span>getRuleID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t usbguard::Rule::getRuleID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns rule ID. </p>
<dl class="section return"><dt>Returns</dt><dd>Rule ID. </dd></dl>

</div>
</div>
<a id="ae5e7c180cbdfbd3a8065dbea53eadfb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5e7c180cbdfbd3a8065dbea53eadfb4">&#9670;&nbsp;</a></span>getSerial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; usbguard::Rule::getSerial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns serial number. </p>
<dl class="section return"><dt>Returns</dt><dd>Serial number. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusbguard_1_1Rule_1_1Attribute.html#a3a3c2b218c7b807d93e307e02bc14a74">get()</a> </dd></dl>

</div>
</div>
<a id="ae74066315ec93a4d6a1a361f46078874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae74066315ec93a4d6a1a361f46078874">&#9670;&nbsp;</a></span>getTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fc">Rule::Target</a> usbguard::Rule::getTarget </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns rule target. </p>
<dl class="section return"><dt>Returns</dt><dd>Rule target. </dd></dl>

</div>
</div>
<a id="ac74f8ceab1c0d691bcc6dd1d681fe5e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74f8ceab1c0d691bcc6dd1d681fe5e6">&#9670;&nbsp;</a></span>getViaPort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; usbguard::Rule::getViaPort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns USB port through which the device is connected. </p>
<dl class="section return"><dt>Returns</dt><dd>USB port through which the device is connected. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusbguard_1_1Rule_1_1Attribute.html#a3a3c2b218c7b807d93e307e02bc14a74">get()</a> </dd></dl>

</div>
</div>
<a id="ac2ff4c50beb0965251289c1e330a920b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2ff4c50beb0965251289c1e330a920b">&#9670;&nbsp;</a></span>getWithConnectType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; usbguard::Rule::getWithConnectType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns type of conncetion USB device uses. </p>
<dl class="section return"><dt>Returns</dt><dd>Type of connection USB device uses. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusbguard_1_1Rule_1_1Attribute.html#a3a3c2b218c7b807d93e307e02bc14a74">get()</a> </dd></dl>

</div>
</div>
<a id="a9bd2bc1a0181d0e4815ee763507952de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bd2bc1a0181d0e4815ee763507952de">&#9670;&nbsp;</a></span>internal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; RulePrivate &gt; &amp; usbguard::Rule::internal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns reference to mutable RulePrivate object of this rule. </p>
<dl class="section return"><dt>Returns</dt><dd>Mutable RulePrivate. </dd></dl>

</div>
</div>
<a id="a6d40817a748dbad90a4fb9d5ee8e17b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d40817a748dbad90a4fb9d5ee8e17b2">&#9670;&nbsp;</a></span>internal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::unique_ptr&lt; RulePrivate &gt; &amp; usbguard::Rule::internal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns reference to imutable RulePrivate object of this rule. </p>
<dl class="section return"><dt>Returns</dt><dd>Imutable RulePrivate. </dd></dl>

</div>
</div>
<a id="a6b2156844e376b882355bbfa6c82e0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b2156844e376b882355bbfa6c82e0ec">&#9670;&nbsp;</a></span>isImplicit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool usbguard::Rule::isImplicit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the rule is implicit (rule has default rule ID). </p>
<dl class="section return"><dt>Returns</dt><dd>True if rule has default rule ID, false otherwise. </dd></dl>

</div>
</div>
<a id="a6e6731a4b3098e2410bf0096f33dfbed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e6731a4b3098e2410bf0096f33dfbed">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">usbguard::Rule::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if rule target is neither unknown nor invalid nor empty. </p>
<dl class="section return"><dt>Returns</dt><dd>True if rule target is neither unknown nor invalid nor empty, false otherwise. </dd></dl>

</div>
</div>
<a id="a58f4eb9adc6c8e44092ab00cc0a2fbfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58f4eb9adc6c8e44092ab00cc0a2fbfd">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classusbguard_1_1Rule.html">Rule</a> &amp; usbguard::Rule::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classusbguard_1_1Rule.html">Rule</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignes rhs rule to this. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Rule to assign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This object. </dd></dl>

</div>
</div>
<a id="a3191f0c3dc572cbc96b0685164c27ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3191f0c3dc572cbc96b0685164c27ef3">&#9670;&nbsp;</a></span>setDeviceID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbguard::Rule::setDeviceID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classusbguard_1_1USBDeviceID.html">USBDeviceID</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets USB Device ID attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>USB device ID to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusbguard_1_1Rule_1_1Attribute.html#a502c108015a7010a3216de4cd37854b4">set()</a> </dd></dl>

</div>
</div>
<a id="ad2def4a0a74c42a03e35f1042e0c2ba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2def4a0a74c42a03e35f1042e0c2ba9">&#9670;&nbsp;</a></span>setHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbguard::Rule::setHash </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets device hash attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Device hash to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusbguard_1_1Rule_1_1Attribute.html#a502c108015a7010a3216de4cd37854b4">set()</a> </dd></dl>

</div>
</div>
<a id="aa56ad2cc37a53a6963cc63f99672789b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa56ad2cc37a53a6963cc63f99672789b">&#9670;&nbsp;</a></span>setLabel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbguard::Rule::setLabel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets rule label attribute. </p>
<p>Label assosiates an arbitrary string with a rule. This string can, for instance, be used to store the origin of the rule or some contextual information about it. It is not used when testing if a rule applies to a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Label to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusbguard_1_1Rule_1_1Attribute.html#a502c108015a7010a3216de4cd37854b4">set()</a> </dd></dl>

</div>
</div>
<a id="a4b6f3166d7b63cc51a37a1fdff39d3b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b6f3166d7b63cc51a37a1fdff39d3b3">&#9670;&nbsp;</a></span>setName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbguard::Rule::setName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets device name attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Device name to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusbguard_1_1Rule_1_1Attribute.html#a502c108015a7010a3216de4cd37854b4">set()</a> </dd></dl>

</div>
</div>
<a id="a1ae177e4f146633274c8e5ff7ee8ef88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ae177e4f146633274c8e5ff7ee8ef88">&#9670;&nbsp;</a></span>setOperatorFromString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classusbguard_1_1Rule.html#a54b949622369234b348c7f4d4e91ebc1">Rule::SetOperator</a> usbguard::Rule::setOperatorFromString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>set_operator_string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts string into set operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set_operator_string</td><td>String to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Set operator. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>If given string does not contain valid set operator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a235f36bd67b5567a8981dfe6f24f48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a235f36bd67b5567a8981dfe6f24f48">&#9670;&nbsp;</a></span>setOperatorToString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string usbguard::Rule::setOperatorToString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classusbguard_1_1Rule.html#a54b949622369234b348c7f4d4e91ebc1">Rule::SetOperator</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts given set operator to its string representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>Set operator to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String representation of given set operator. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>If string representation for given set operator does not exist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57ff825c0f2444046cb6036ea952df62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57ff825c0f2444046cb6036ea952df62">&#9670;&nbsp;</a></span>setParentHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbguard::Rule::setParentHash </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets parent hash attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Parent hash to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusbguard_1_1Rule_1_1Attribute.html#a502c108015a7010a3216de4cd37854b4">set()</a> </dd></dl>

</div>
</div>
<a id="a58c4553af8b30fdf39aaa54a8c450373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58c4553af8b30fdf39aaa54a8c450373">&#9670;&nbsp;</a></span>setRuleID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbguard::Rule::setRuleID </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rule_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets rule ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rule_id</td><td>Rule ID to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a214ca4fdf7b33c9ee32641c73085fb1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a214ca4fdf7b33c9ee32641c73085fb1e">&#9670;&nbsp;</a></span>setSerial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbguard::Rule::setSerial </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets serial number attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Serial number to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusbguard_1_1Rule_1_1Attribute.html#a502c108015a7010a3216de4cd37854b4">set()</a> </dd></dl>

</div>
</div>
<a id="a13510a25773e4bbabe2b6e9f78e39f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13510a25773e4bbabe2b6e9f78e39f79">&#9670;&nbsp;</a></span>setTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbguard::Rule::setTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fc">Rule::Target</a>&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets rule target. </p>
<p>In other words, sets whether USB device will be authorized for use or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Rule target to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b124dbe9809a0b608567eb8a8dc923d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b124dbe9809a0b608567eb8a8dc923d">&#9670;&nbsp;</a></span>setViaPort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbguard::Rule::setViaPort </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets via-port attribute. </p>
<p>Describes through which USB port the device is connected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Port to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusbguard_1_1Rule_1_1Attribute.html#a502c108015a7010a3216de4cd37854b4">set()</a> </dd></dl>

</div>
</div>
<a id="a133e49e3be809f0376e83cd2fc45e8f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a133e49e3be809f0376e83cd2fc45e8f0">&#9670;&nbsp;</a></span>setWithConnectType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbguard::Rule::setWithConnectType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets with-connect-type attribute. </p>
<p>Describes what type of connection USB device uses. Helps to distinguish between internal (hardwired) and external (hotplug) ports.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>With-connect-type to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusbguard_1_1Rule_1_1Attribute.html#a502c108015a7010a3216de4cd37854b4">set()</a> </dd></dl>

</div>
</div>
<a id="a513bf91b5bc68416d42b59cf9140fccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a513bf91b5bc68416d42b59cf9140fccc">&#9670;&nbsp;</a></span>targetFromInteger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fc">Rule::Target</a> usbguard::Rule::targetFromInteger </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>target_integer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts integer into rule target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_integer</td><td>Integer to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Rule target. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>If given integer can not be converted into rule target. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29ef58acc9cf41bc9a0504cdd7663d2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29ef58acc9cf41bc9a0504cdd7663d2c">&#9670;&nbsp;</a></span>targetFromString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fc">Rule::Target</a> usbguard::Rule::targetFromString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target_string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts given string into rule target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_string</td><td>String to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Rule target. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>If string does not contain valid rule target. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1dcb2b31383e8e036eda68e2073d559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1dcb2b31383e8e036eda68e2073d559">&#9670;&nbsp;</a></span>targetToInteger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t usbguard::Rule::targetToInteger </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fc">Rule::Target</a>&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts rule target to its integer representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Rule target to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer representation of given rule target. </dd></dl>

</div>
</div>
<a id="a916bd83c392e0b7f17cfd885f547ffea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a916bd83c392e0b7f17cfd885f547ffea">&#9670;&nbsp;</a></span>targetToString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string usbguard::Rule::targetToString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fc">Rule::Target</a>&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts given rule target to its string representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Rule target to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String representation of given target. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>If no string representation for given rule target has been found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab45b1cd9c6e0b7a61cb3aad0dfccaf56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab45b1cd9c6e0b7a61cb3aad0dfccaf56">&#9670;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string usbguard::Rule::toString </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invalid</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hide_serial</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns string representation of this rule. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">invalid</td><td>If rule target is invalid and this option is set to true, then no exception will be thrown but string "&lt;invalid&gt;" will be put instead of rule target into the string. </td></tr>
    <tr><td class="paramname">hide_serial</td><td>If true, serial number and any PII (Personally identifiable information) will not be included in the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String representation of this rule. </dd></dl>

</div>
</div>
<a id="a46cb2e10e705921d6f10162b33816565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46cb2e10e705921d6f10162b33816565">&#9670;&nbsp;</a></span>updateMetaDataCounters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbguard::Rule::updateMetaDataCounters </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>applied</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>evaluated</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates meta-data last applied and last evaluated counters. </p>
<p>RulePrivate object contains three meta-data counters:</p><ul>
<li>when was Rule object created.</li>
<li>when was rule last applied.</li>
<li>when was rule last evaluated.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">applied</td><td>If true, last applied counter is updated to current time. </td></tr>
    <tr><td class="paramname">evaluated</td><td>If true, last evaluated counter is updated to current time. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Rule_8hpp_source.html">Rule.hpp</a></li>
<li>Rule.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
