<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>USBGuard: usbguard::Device Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="usbguard-logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">USBGuard
   </div>
   <div id="projectbrief">Software framework that protects your computer against rogue USB devices by implementing basic whitelisting and blacklisting capabilities.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>usbguard</b></li><li class="navelem"><a class="el" href="classusbguard_1_1Device.html">Device</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classusbguard_1_1Device-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">usbguard::Device Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents USB device in USBGuard.  
 <a href="classusbguard_1_1Device.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Device_8hpp_source.html">Device.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aca4aaf2a6bd86baa0f32e6ee32312d61"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Device.html#aca4aaf2a6bd86baa0f32e6ee32312d61">Device</a> (<a class="el" href="classusbguard_1_1DeviceManager.html">DeviceManager</a> &amp;<a class="el" href="classusbguard_1_1Device.html#afe2c290c3c913922f6210587d0ddf9b9">manager</a>)</td></tr>
<tr class="memdesc:aca4aaf2a6bd86baa0f32e6ee32312d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs new device object and sets its <a class="el" href="classusbguard_1_1DeviceManager.html">device manager</a>.  <a href="#aca4aaf2a6bd86baa0f32e6ee32312d61">More...</a><br /></td></tr>
<tr class="separator:aca4aaf2a6bd86baa0f32e6ee32312d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1eb4a9120784f17f8e59349dae25aad"><td class="memItemLeft" align="right" valign="top"><a id="ad1eb4a9120784f17f8e59349dae25aad"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Device.html#ad1eb4a9120784f17f8e59349dae25aad">~Device</a> ()</td></tr>
<tr class="memdesc:ad1eb4a9120784f17f8e59349dae25aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor. <br /></td></tr>
<tr class="separator:ad1eb4a9120784f17f8e59349dae25aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09aafe53287b4b1191783ba924414655"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Device.html#a09aafe53287b4b1191783ba924414655">Device</a> (const <a class="el" href="classusbguard_1_1Device.html">Device</a> &amp;rhs)</td></tr>
<tr class="memdesc:a09aafe53287b4b1191783ba924414655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs device object based on rhs.  <a href="#a09aafe53287b4b1191783ba924414655">More...</a><br /></td></tr>
<tr class="separator:a09aafe53287b4b1191783ba924414655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab420e9215ead529a8d100fb6a3899f71"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classusbguard_1_1Device.html">Device</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Device.html#ab420e9215ead529a8d100fb6a3899f71">operator=</a> (const <a class="el" href="classusbguard_1_1Device.html">Device</a> &amp;rhs)</td></tr>
<tr class="memdesc:ab420e9215ead529a8d100fb6a3899f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns rhs to this.  <a href="#ab420e9215ead529a8d100fb6a3899f71">More...</a><br /></td></tr>
<tr class="separator:ab420e9215ead529a8d100fb6a3899f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2c290c3c913922f6210587d0ddf9b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classusbguard_1_1DeviceManager.html">DeviceManager</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Device.html#afe2c290c3c913922f6210587d0ddf9b9">manager</a> () const</td></tr>
<tr class="memdesc:afe2c290c3c913922f6210587d0ddf9b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <a class="el" href="classusbguard_1_1DeviceManager.html">device manager</a> that is responsible for this device.  <a href="#afe2c290c3c913922f6210587d0ddf9b9">More...</a><br /></td></tr>
<tr class="separator:afe2c290c3c913922f6210587d0ddf9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbee2a7a67c27a1ac137174b757717d0"><td class="memItemLeft" align="right" valign="top">std::mutex &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Device.html#acbee2a7a67c27a1ac137174b757717d0">refDeviceMutex</a> ()</td></tr>
<tr class="memdesc:acbee2a7a67c27a1ac137174b757717d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to device mutex.  <a href="#acbee2a7a67c27a1ac137174b757717d0">More...</a><br /></td></tr>
<tr class="separator:acbee2a7a67c27a1ac137174b757717d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaeb9c579beaee2b60b7c9f8a2b0544b"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classusbguard_1_1Rule.html">Rule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Device.html#acaeb9c579beaee2b60b7c9f8a2b0544b">getDeviceRule</a> (bool with_port=true, bool with_parent_hash=true, bool match_rule=false)</td></tr>
<tr class="memdesc:acaeb9c579beaee2b60b7c9f8a2b0544b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates device rule for this USB device.  <a href="#acaeb9c579beaee2b60b7c9f8a2b0544b">More...</a><br /></td></tr>
<tr class="separator:acaeb9c579beaee2b60b7c9f8a2b0544b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9894f595d319f26babfd913ea66d98"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Device.html#a3a9894f595d319f26babfd913ea66d98">hashString</a> (const std::string &amp;value) const</td></tr>
<tr class="memdesc:a3a9894f595d319f26babfd913ea66d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes a given string and returns it.  <a href="#a3a9894f595d319f26babfd913ea66d98">More...</a><br /></td></tr>
<tr class="separator:a3a9894f595d319f26babfd913ea66d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709e9cb45655b6056a25bdc338beb24f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Device.html#a709e9cb45655b6056a25bdc338beb24f">initializeHash</a> ()</td></tr>
<tr class="memdesc:a709e9cb45655b6056a25bdc338beb24f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize hash for this device.  <a href="#a709e9cb45655b6056a25bdc338beb24f">More...</a><br /></td></tr>
<tr class="separator:a709e9cb45655b6056a25bdc338beb24f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470991255efde5361154ba294e70fad5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Device.html#a470991255efde5361154ba294e70fad5">updateHash</a> (const void *ptr, size_t size)</td></tr>
<tr class="memdesc:a470991255efde5361154ba294e70fad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes given data and creates new hash value.  <a href="#a470991255efde5361154ba294e70fad5">More...</a><br /></td></tr>
<tr class="separator:a470991255efde5361154ba294e70fad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba08252ef70bc19847b2298855b4cd4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Device.html#aba08252ef70bc19847b2298855b4cd4f">updateHash</a> (std::istream &amp;descriptor_stream, size_t expected_size)</td></tr>
<tr class="memdesc:aba08252ef70bc19847b2298855b4cd4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes given descriptor stream and creates new hash value.  <a href="#aba08252ef70bc19847b2298855b4cd4f">More...</a><br /></td></tr>
<tr class="separator:aba08252ef70bc19847b2298855b4cd4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c0e6d2c70acf763f2f037a1ccb0041"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Device.html#ab2c0e6d2c70acf763f2f037a1ccb0041">finalizeHash</a> ()</td></tr>
<tr class="memdesc:ab2c0e6d2c70acf763f2f037a1ccb0041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizes hash by encoding it into base64.  <a href="#ab2c0e6d2c70acf763f2f037a1ccb0041">More...</a><br /></td></tr>
<tr class="separator:ab2c0e6d2c70acf763f2f037a1ccb0041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e9d49f1773e7af3132601a2a4edf16"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Device.html#a38e9d49f1773e7af3132601a2a4edf16">getHash</a> () const</td></tr>
<tr class="memdesc:a38e9d49f1773e7af3132601a2a4edf16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns device hash.  <a href="#a38e9d49f1773e7af3132601a2a4edf16">More...</a><br /></td></tr>
<tr class="separator:a38e9d49f1773e7af3132601a2a4edf16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44615a7ca75d52a69c7df40e3581626"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Device.html#aa44615a7ca75d52a69c7df40e3581626">setParentHash</a> (const std::string &amp;hash)</td></tr>
<tr class="memdesc:aa44615a7ca75d52a69c7df40e3581626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets parent hash for this device.  <a href="#aa44615a7ca75d52a69c7df40e3581626">More...</a><br /></td></tr>
<tr class="separator:aa44615a7ca75d52a69c7df40e3581626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498b2681d7ae98600dc79a9745cbf562"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Device.html#a498b2681d7ae98600dc79a9745cbf562">setID</a> (uint32_t id)</td></tr>
<tr class="memdesc:a498b2681d7ae98600dc79a9745cbf562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets device ID.  <a href="#a498b2681d7ae98600dc79a9745cbf562">More...</a><br /></td></tr>
<tr class="separator:a498b2681d7ae98600dc79a9745cbf562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f3ad6e11a894e802ada38eb541a5fe8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Device.html#a4f3ad6e11a894e802ada38eb541a5fe8">getID</a> () const</td></tr>
<tr class="memdesc:a4f3ad6e11a894e802ada38eb541a5fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns device ID.  <a href="#a4f3ad6e11a894e802ada38eb541a5fe8">More...</a><br /></td></tr>
<tr class="separator:a4f3ad6e11a894e802ada38eb541a5fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a792a73139011d51a10f0486f8e03ceea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Device.html#a792a73139011d51a10f0486f8e03ceea">setParentID</a> (uint32_t id)</td></tr>
<tr class="memdesc:a792a73139011d51a10f0486f8e03ceea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets parent ID for this device.  <a href="#a792a73139011d51a10f0486f8e03ceea">More...</a><br /></td></tr>
<tr class="separator:a792a73139011d51a10f0486f8e03ceea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc61064e5b81ce428f5d6d7c9ae1f53"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Device.html#a8cc61064e5b81ce428f5d6d7c9ae1f53">getParentID</a> () const</td></tr>
<tr class="memdesc:a8cc61064e5b81ce428f5d6d7c9ae1f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns parent ID.  <a href="#a8cc61064e5b81ce428f5d6d7c9ae1f53">More...</a><br /></td></tr>
<tr class="separator:a8cc61064e5b81ce428f5d6d7c9ae1f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e348ec0b621bf268fb2890b63b38fda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Device.html#a7e348ec0b621bf268fb2890b63b38fda">setTarget</a> (<a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fc">Rule::Target</a> target)</td></tr>
<tr class="memdesc:a7e348ec0b621bf268fb2890b63b38fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets given target for this device.  <a href="#a7e348ec0b621bf268fb2890b63b38fda">More...</a><br /></td></tr>
<tr class="separator:a7e348ec0b621bf268fb2890b63b38fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776d38164055825f4d7f3bbb5fc123af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fc">Rule::Target</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Device.html#a776d38164055825f4d7f3bbb5fc123af">getTarget</a> () const</td></tr>
<tr class="memdesc:a776d38164055825f4d7f3bbb5fc123af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns rule target for this device.  <a href="#a776d38164055825f4d7f3bbb5fc123af">More...</a><br /></td></tr>
<tr class="separator:a776d38164055825f4d7f3bbb5fc123af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d62c76bca6405ba9390ee26cc7d1c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Device.html#ad7d62c76bca6405ba9390ee26cc7d1c8">setName</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ad7d62c76bca6405ba9390ee26cc7d1c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets device name.  <a href="#ad7d62c76bca6405ba9390ee26cc7d1c8">More...</a><br /></td></tr>
<tr class="separator:ad7d62c76bca6405ba9390ee26cc7d1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe488eb2a727d3c1cc0cc6fdd1aa594c"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Device.html#afe488eb2a727d3c1cc0cc6fdd1aa594c">getName</a> () const</td></tr>
<tr class="memdesc:afe488eb2a727d3c1cc0cc6fdd1aa594c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns device name.  <a href="#afe488eb2a727d3c1cc0cc6fdd1aa594c">More...</a><br /></td></tr>
<tr class="separator:afe488eb2a727d3c1cc0cc6fdd1aa594c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af429abcf13f741e7901d3b525a196a28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Device.html#af429abcf13f741e7901d3b525a196a28">setDeviceID</a> (const <a class="el" href="classusbguard_1_1USBDeviceID.html">USBDeviceID</a> &amp;device_id)</td></tr>
<tr class="memdesc:af429abcf13f741e7901d3b525a196a28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets device ID.  <a href="#af429abcf13f741e7901d3b525a196a28">More...</a><br /></td></tr>
<tr class="separator:af429abcf13f741e7901d3b525a196a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7300487e5e5ffea904fb8635ed9ffda3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classusbguard_1_1USBDeviceID.html">USBDeviceID</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Device.html#a7300487e5e5ffea904fb8635ed9ffda3">getDeviceID</a> () const</td></tr>
<tr class="memdesc:a7300487e5e5ffea904fb8635ed9ffda3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns device ID.  <a href="#a7300487e5e5ffea904fb8635ed9ffda3">More...</a><br /></td></tr>
<tr class="separator:a7300487e5e5ffea904fb8635ed9ffda3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a919d6a71023dee547ff1c635450016"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Device.html#a3a919d6a71023dee547ff1c635450016">setPort</a> (const std::string &amp;port)</td></tr>
<tr class="memdesc:a3a919d6a71023dee547ff1c635450016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets port through which the device is connected.  <a href="#a3a919d6a71023dee547ff1c635450016">More...</a><br /></td></tr>
<tr class="separator:a3a919d6a71023dee547ff1c635450016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37380051efaf50e1742cdb16d1eb6ee3"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Device.html#a37380051efaf50e1742cdb16d1eb6ee3">getPort</a> () const</td></tr>
<tr class="memdesc:a37380051efaf50e1742cdb16d1eb6ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns port through which the device is connected.  <a href="#a37380051efaf50e1742cdb16d1eb6ee3">More...</a><br /></td></tr>
<tr class="separator:a37380051efaf50e1742cdb16d1eb6ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21bc70528d4d79ac9381acbe71322db3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Device.html#a21bc70528d4d79ac9381acbe71322db3">setSerial</a> (const std::string &amp;serial_number)</td></tr>
<tr class="memdesc:a21bc70528d4d79ac9381acbe71322db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets device serial number.  <a href="#a21bc70528d4d79ac9381acbe71322db3">More...</a><br /></td></tr>
<tr class="separator:a21bc70528d4d79ac9381acbe71322db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132e2921eba73aa0de855730d445f6a7"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Device.html#a132e2921eba73aa0de855730d445f6a7">getSerial</a> () const</td></tr>
<tr class="memdesc:a132e2921eba73aa0de855730d445f6a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns device serial number.  <a href="#a132e2921eba73aa0de855730d445f6a7">More...</a><br /></td></tr>
<tr class="separator:a132e2921eba73aa0de855730d445f6a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb84c1cf43b4e0e9ba03a33d61eb8f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Device.html#abcb84c1cf43b4e0e9ba03a33d61eb8f9">setConnectType</a> (const std::string &amp;connect_type)</td></tr>
<tr class="memdesc:abcb84c1cf43b4e0e9ba03a33d61eb8f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets device connection type.  <a href="#abcb84c1cf43b4e0e9ba03a33d61eb8f9">More...</a><br /></td></tr>
<tr class="separator:abcb84c1cf43b4e0e9ba03a33d61eb8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31962efc9b772e89cc4c185d5d5493b4"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Device.html#a31962efc9b772e89cc4c185d5d5493b4">getConnectType</a> () const</td></tr>
<tr class="memdesc:a31962efc9b772e89cc4c185d5d5493b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns device connection type.  <a href="#a31962efc9b772e89cc4c185d5d5493b4">More...</a><br /></td></tr>
<tr class="separator:a31962efc9b772e89cc4c185d5d5493b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee07fa59cc8572081abfbb2b639d688c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classusbguard_1_1USBInterfaceType.html">USBInterfaceType</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Device.html#aee07fa59cc8572081abfbb2b639d688c">refMutableInterfaceTypes</a> ()</td></tr>
<tr class="memdesc:aee07fa59cc8572081abfbb2b639d688c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to mutable vector of interface types of this USB device.  <a href="#aee07fa59cc8572081abfbb2b639d688c">More...</a><br /></td></tr>
<tr class="separator:aee07fa59cc8572081abfbb2b639d688c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a045e41a6d5c9cf31e3f31c10a04e0"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classusbguard_1_1USBInterfaceType.html">USBInterfaceType</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Device.html#a94a045e41a6d5c9cf31e3f31c10a04e0">getInterfaceTypes</a> () const</td></tr>
<tr class="memdesc:a94a045e41a6d5c9cf31e3f31c10a04e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to vector of interface types of this USB device.  <a href="#a94a045e41a6d5c9cf31e3f31c10a04e0">More...</a><br /></td></tr>
<tr class="separator:a94a045e41a6d5c9cf31e3f31c10a04e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0ab42a3a3c9f9054856967e813405a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Device.html#a3f0ab42a3a3c9f9054856967e813405a">isController</a> () const =0</td></tr>
<tr class="memdesc:a3f0ab42a3a3c9f9054856967e813405a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether this USB device is a controller or not.  <a href="#a3f0ab42a3a3c9f9054856967e813405a">More...</a><br /></td></tr>
<tr class="separator:a3f0ab42a3a3c9f9054856967e813405a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7b4ad6c567542e131707bac212e253"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Device.html#a4d7b4ad6c567542e131707bac212e253">getSystemName</a> () const =0</td></tr>
<tr class="memdesc:a4d7b4ad6c567542e131707bac212e253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns absolute path of this USB device.  <a href="#a4d7b4ad6c567542e131707bac212e253">More...</a><br /></td></tr>
<tr class="separator:a4d7b4ad6c567542e131707bac212e253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1cd718270d3f78bf41b1692de9d520"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Device.html#a1d1cd718270d3f78bf41b1692de9d520">loadDeviceDescriptor</a> (<a class="el" href="classusbguard_1_1USBDescriptorParser.html">USBDescriptorParser</a> *parser, const <a class="el" href="structusbguard_1_1USBDescriptor.html">USBDescriptor</a> *descriptor)</td></tr>
<tr class="memdesc:a1d1cd718270d3f78bf41b1692de9d520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads device descriptor using given USB descriptor parser.  <a href="#a1d1cd718270d3f78bf41b1692de9d520">More...</a><br /></td></tr>
<tr class="separator:a1d1cd718270d3f78bf41b1692de9d520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155e8b673a2652625ddb20bc32133b99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Device.html#a155e8b673a2652625ddb20bc32133b99">loadConfigurationDescriptor</a> (<a class="el" href="classusbguard_1_1USBDescriptorParser.html">USBDescriptorParser</a> *parser, const <a class="el" href="structusbguard_1_1USBDescriptor.html">USBDescriptor</a> *descriptor)</td></tr>
<tr class="memdesc:a155e8b673a2652625ddb20bc32133b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads configuration descriptor using given USB descriptor parser.  <a href="#a155e8b673a2652625ddb20bc32133b99">More...</a><br /></td></tr>
<tr class="separator:a155e8b673a2652625ddb20bc32133b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0478efab45b86d485d8cf4071ea701f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Device.html#a0478efab45b86d485d8cf4071ea701f5">loadInterfaceDescriptor</a> (<a class="el" href="classusbguard_1_1USBDescriptorParser.html">USBDescriptorParser</a> *parser, const <a class="el" href="structusbguard_1_1USBDescriptor.html">USBDescriptor</a> *descriptor)</td></tr>
<tr class="memdesc:a0478efab45b86d485d8cf4071ea701f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads interface descriptor using given USB descriptor parser.  <a href="#a0478efab45b86d485d8cf4071ea701f5">More...</a><br /></td></tr>
<tr class="separator:a0478efab45b86d485d8cf4071ea701f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6a6e3bc70fb818f00ad919e99d7fbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Device.html#abd6a6e3bc70fb818f00ad919e99d7fbb">loadEndpointDescriptor</a> (<a class="el" href="classusbguard_1_1USBDescriptorParser.html">USBDescriptorParser</a> *parser, const <a class="el" href="structusbguard_1_1USBDescriptor.html">USBDescriptor</a> *descriptor)</td></tr>
<tr class="memdesc:abd6a6e3bc70fb818f00ad919e99d7fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads endpoint descriptor using given USB descriptor parser.  <a href="#abd6a6e3bc70fb818f00ad919e99d7fbb">More...</a><br /></td></tr>
<tr class="separator:abd6a6e3bc70fb818f00ad919e99d7fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents USB device in USBGuard. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aca4aaf2a6bd86baa0f32e6ee32312d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4aaf2a6bd86baa0f32e6ee32312d61">&#9670;&nbsp;</a></span>Device() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">usbguard::Device::Device </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classusbguard_1_1DeviceManager.html">DeviceManager</a> &amp;&#160;</td>
          <td class="paramname"><em>manager</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs new device object and sets its <a class="el" href="classusbguard_1_1DeviceManager.html">device manager</a>. </p>
<p>Device ID is set to default, parent device ID is set to root ID and target rule is set to unknown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">manager</td><td><a class="el" href="classusbguard_1_1DeviceManager.html">device manager</a> that is responsible for this device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusbguard_1_1Rule.html#a850e2d86d9cba0d96c4006b0ce3258d9">DefaultID()</a> </dd>
<dd>
<a class="el" href="classusbguard_1_1Rule.html#a726fae0a339a50631a1a2b80e92301b3">RootID()</a> </dd>
<dd>
<a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fc">Target</a> </dd></dl>

</div>
</div>
<a id="a09aafe53287b4b1191783ba924414655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09aafe53287b4b1191783ba924414655">&#9670;&nbsp;</a></span>Device() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">usbguard::Device::Device </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classusbguard_1_1Device.html">Device</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs device object based on rhs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Device object to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab2c0e6d2c70acf763f2f037a1ccb0041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2c0e6d2c70acf763f2f037a1ccb0041">&#9670;&nbsp;</a></span>finalizeHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string usbguard::Device::finalizeHash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalizes hash by encoding it into base64. </p>
<dl class="section return"><dt>Returns</dt><dd>Finalized hash. </dd></dl>

</div>
</div>
<a id="a31962efc9b772e89cc4c185d5d5493b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31962efc9b772e89cc4c185d5d5493b4">&#9670;&nbsp;</a></span>getConnectType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; usbguard::Device::getConnectType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns device connection type. </p>
<dl class="section return"><dt>Returns</dt><dd>Device connection type. </dd></dl>

</div>
</div>
<a id="a7300487e5e5ffea904fb8635ed9ffda3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7300487e5e5ffea904fb8635ed9ffda3">&#9670;&nbsp;</a></span>getDeviceID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classusbguard_1_1USBDeviceID.html">USBDeviceID</a> &amp; usbguard::Device::getDeviceID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns device ID. </p>
<dl class="section return"><dt>Returns</dt><dd>Device ID. </dd></dl>

</div>
</div>
<a id="acaeb9c579beaee2b60b7c9f8a2b0544b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaeb9c579beaee2b60b7c9f8a2b0544b">&#9670;&nbsp;</a></span>getDeviceRule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classusbguard_1_1Rule.html">Rule</a> &gt; usbguard::Device::getDeviceRule </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>with_port</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>with_parent_hash</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>match_rule</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates device rule for this USB device. </p>
<p>Generated device rule is composed of: ID, rule target, device ID, serial number, connection type, port (optional), interface types, device name, hash, parent hash (optional).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">with_port</td><td>If true, port is included in generated rule. </td></tr>
    <tr><td class="paramname">with_parent_hash</td><td>If true, parent hash is included in generated rule. </td></tr>
    <tr><td class="paramname">match_rule</td><td>If true, sets rule target to match. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Device rule for this USB device. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>If <code>with_parent_hash</code> is true and parent hash value is not available. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38e9d49f1773e7af3132601a2a4edf16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e9d49f1773e7af3132601a2a4edf16">&#9670;&nbsp;</a></span>getHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; usbguard::Device::getHash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns device hash. </p>
<dl class="section return"><dt>Returns</dt><dd>Device hash. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">USBGUARD_BUG</td><td>If device hash is not finalized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusbguard_1_1Device.html#ab2c0e6d2c70acf763f2f037a1ccb0041">finalizeHash()</a> </dd></dl>

</div>
</div>
<a id="a4f3ad6e11a894e802ada38eb541a5fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f3ad6e11a894e802ada38eb541a5fe8">&#9670;&nbsp;</a></span>getID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t usbguard::Device::getID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns device ID. </p>
<dl class="section return"><dt>Returns</dt><dd>Device ID. </dd></dl>

</div>
</div>
<a id="a94a045e41a6d5c9cf31e3f31c10a04e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94a045e41a6d5c9cf31e3f31c10a04e0">&#9670;&nbsp;</a></span>getInterfaceTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classusbguard_1_1USBInterfaceType.html">USBInterfaceType</a> &gt; &amp; usbguard::Device::getInterfaceTypes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns reference to vector of interface types of this USB device. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to vector of interface types of this USB device. </dd></dl>

</div>
</div>
<a id="afe488eb2a727d3c1cc0cc6fdd1aa594c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe488eb2a727d3c1cc0cc6fdd1aa594c">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; usbguard::Device::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns device name. </p>
<dl class="section return"><dt>Returns</dt><dd>Device name. </dd></dl>

</div>
</div>
<a id="a8cc61064e5b81ce428f5d6d7c9ae1f53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cc61064e5b81ce428f5d6d7c9ae1f53">&#9670;&nbsp;</a></span>getParentID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t usbguard::Device::getParentID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns parent ID. </p>
<dl class="section return"><dt>Returns</dt><dd>Parent ID. </dd></dl>

</div>
</div>
<a id="a37380051efaf50e1742cdb16d1eb6ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37380051efaf50e1742cdb16d1eb6ee3">&#9670;&nbsp;</a></span>getPort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; usbguard::Device::getPort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns port through which the device is connected. </p>
<dl class="section return"><dt>Returns</dt><dd>Port through which the device is connected. </dd></dl>

</div>
</div>
<a id="a132e2921eba73aa0de855730d445f6a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a132e2921eba73aa0de855730d445f6a7">&#9670;&nbsp;</a></span>getSerial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; usbguard::Device::getSerial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns device serial number. </p>
<dl class="section return"><dt>Returns</dt><dd>Device serial number. </dd></dl>

</div>
</div>
<a id="a4d7b4ad6c567542e131707bac212e253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d7b4ad6c567542e131707bac212e253">&#9670;&nbsp;</a></span>getSystemName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string usbguard::Device::getSystemName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns absolute path of this USB device. </p>
<dl class="section return"><dt>Returns</dt><dd>Absolute path of this USB device. </dd></dl>

</div>
</div>
<a id="a776d38164055825f4d7f3bbb5fc123af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a776d38164055825f4d7f3bbb5fc123af">&#9670;&nbsp;</a></span>getTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fc">Rule::Target</a> usbguard::Device::getTarget </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns rule target for this device. </p>
<dl class="section return"><dt>Returns</dt><dd>Rule target for this device. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fc">Target</a> </dd></dl>

</div>
</div>
<a id="a3a9894f595d319f26babfd913ea66d98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a9894f595d319f26babfd913ea66d98">&#9670;&nbsp;</a></span>hashString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string usbguard::Device::hashString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hashes a given string and returns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value to hash. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Hashed input string. </dd></dl>

</div>
</div>
<a id="a709e9cb45655b6056a25bdc338beb24f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a709e9cb45655b6056a25bdc338beb24f">&#9670;&nbsp;</a></span>initializeHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbguard::Device::initializeHash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize hash for this device. </p>
<p>Hash is initialized from name, vendor ID, product ID and serial number of the device.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Exception</td><td>If vendor or product ID is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f0ab42a3a3c9f9054856967e813405a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f0ab42a3a3c9f9054856967e813405a">&#9670;&nbsp;</a></span>isController()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool usbguard::Device::isController </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether this USB device is a controller or not. </p>
<dl class="section return"><dt>Returns</dt><dd>True if this USB device is a controller, false otherwise. </dd></dl>

</div>
</div>
<a id="a155e8b673a2652625ddb20bc32133b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a155e8b673a2652625ddb20bc32133b99">&#9670;&nbsp;</a></span>loadConfigurationDescriptor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbguard::Device::loadConfigurationDescriptor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classusbguard_1_1USBDescriptorParser.html">USBDescriptorParser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structusbguard_1_1USBDescriptor.html">USBDescriptor</a> *&#160;</td>
          <td class="paramname"><em>descriptor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads configuration descriptor using given USB descriptor parser. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Parser that will parse the configuration descriptor. </td></tr>
    <tr><td class="paramname">descriptor</td><td>Configuration descriptor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>If parent device descriptor is missing while trying to load configuration descriptor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d1cd718270d3f78bf41b1692de9d520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d1cd718270d3f78bf41b1692de9d520">&#9670;&nbsp;</a></span>loadDeviceDescriptor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbguard::Device::loadDeviceDescriptor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classusbguard_1_1USBDescriptorParser.html">USBDescriptorParser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structusbguard_1_1USBDescriptor.html">USBDescriptor</a> *&#160;</td>
          <td class="paramname"><em>descriptor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads device descriptor using given USB descriptor parser. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Parser that will parse the USB device descriptor. </td></tr>
    <tr><td class="paramname">descriptor</td><td>USB Device descriptor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>If there are multiple device descriptors for one device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd6a6e3bc70fb818f00ad919e99d7fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd6a6e3bc70fb818f00ad919e99d7fbb">&#9670;&nbsp;</a></span>loadEndpointDescriptor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbguard::Device::loadEndpointDescriptor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classusbguard_1_1USBDescriptorParser.html">USBDescriptorParser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structusbguard_1_1USBDescriptor.html">USBDescriptor</a> *&#160;</td>
          <td class="paramname"><em>descriptor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads endpoint descriptor using given USB descriptor parser. </p>
<dl class="section note"><dt>Note</dt><dd>Warning: This method can receive USB descriptors of two sizes! (enpoint, audio endpoint).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Parser that will parse the endpoint descriptor. </td></tr>
    <tr><td class="paramname">descriptor</td><td>Endpoint descriptor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>If parent interface descriptor is missing while trying to load enpoint descriptor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0478efab45b86d485d8cf4071ea701f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0478efab45b86d485d8cf4071ea701f5">&#9670;&nbsp;</a></span>loadInterfaceDescriptor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbguard::Device::loadInterfaceDescriptor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classusbguard_1_1USBDescriptorParser.html">USBDescriptorParser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structusbguard_1_1USBDescriptor.html">USBDescriptor</a> *&#160;</td>
          <td class="paramname"><em>descriptor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads interface descriptor using given USB descriptor parser. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Parser that will parse the interface descriptor. </td></tr>
    <tr><td class="paramname">descriptor</td><td>Interface descriptor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>If parent configuration descriptor is missing while trying to load interface descriptor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe2c290c3c913922f6210587d0ddf9b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe2c290c3c913922f6210587d0ddf9b9">&#9670;&nbsp;</a></span>manager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classusbguard_1_1DeviceManager.html">DeviceManager</a> &amp; usbguard::Device::manager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <a class="el" href="classusbguard_1_1DeviceManager.html">device manager</a> that is responsible for this device. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classusbguard_1_1DeviceManager.html">Device manager</a> that is responsible for this device. </dd></dl>

</div>
</div>
<a id="ab420e9215ead529a8d100fb6a3899f71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab420e9215ead529a8d100fb6a3899f71">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classusbguard_1_1Device.html">Device</a> &amp; usbguard::Device::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classusbguard_1_1Device.html">Device</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns rhs to this. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Device object to assign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This object. </dd></dl>

</div>
</div>
<a id="acbee2a7a67c27a1ac137174b757717d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbee2a7a67c27a1ac137174b757717d0">&#9670;&nbsp;</a></span>refDeviceMutex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex &amp; usbguard::Device::refDeviceMutex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns reference to device mutex. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to device mutex. </dd></dl>

</div>
</div>
<a id="aee07fa59cc8572081abfbb2b639d688c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee07fa59cc8572081abfbb2b639d688c">&#9670;&nbsp;</a></span>refMutableInterfaceTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classusbguard_1_1USBInterfaceType.html">USBInterfaceType</a> &gt; &amp; usbguard::Device::refMutableInterfaceTypes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns reference to mutable vector of interface types of this USB device. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to mutable vector of interface types of this USB device. </dd></dl>

</div>
</div>
<a id="abcb84c1cf43b4e0e9ba03a33d61eb8f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcb84c1cf43b4e0e9ba03a33d61eb8f9">&#9670;&nbsp;</a></span>setConnectType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbguard::Device::setConnectType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>connect_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets device connection type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">connect_type</td><td>Connection type to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>If given <code>connection_type</code> is bigger then <code>USB_GENERIC_STRING_MAX_LENGTH</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af429abcf13f741e7901d3b525a196a28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af429abcf13f741e7901d3b525a196a28">&#9670;&nbsp;</a></span>setDeviceID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbguard::Device::setDeviceID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classusbguard_1_1USBDeviceID.html">USBDeviceID</a> &amp;&#160;</td>
          <td class="paramname"><em>device_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets device ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device_id</td><td>Device ID to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a498b2681d7ae98600dc79a9745cbf562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a498b2681d7ae98600dc79a9745cbf562">&#9670;&nbsp;</a></span>setID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbguard::Device::setID </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets device ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Device ID to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7d62c76bca6405ba9390ee26cc7d1c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7d62c76bca6405ba9390ee26cc7d1c8">&#9670;&nbsp;</a></span>setName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbguard::Device::setName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets device name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Device name to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Exception</td><td>If given <code>name</code> is bigger then <code>USB_GENERIC_STRING_MAX_LENGTH</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa44615a7ca75d52a69c7df40e3581626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa44615a7ca75d52a69c7df40e3581626">&#9670;&nbsp;</a></span>setParentHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbguard::Device::setParentHash </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets parent hash for this device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>Parent hash to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a792a73139011d51a10f0486f8e03ceea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a792a73139011d51a10f0486f8e03ceea">&#9670;&nbsp;</a></span>setParentID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbguard::Device::setParentID </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets parent ID for this device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Parent ID to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a919d6a71023dee547ff1c635450016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a919d6a71023dee547ff1c635450016">&#9670;&nbsp;</a></span>setPort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbguard::Device::setPort </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets port through which the device is connected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>Port to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>If given <code>port</code> is bigger then <code>USB_PORT_STRING_MAX_LENGTH</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21bc70528d4d79ac9381acbe71322db3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21bc70528d4d79ac9381acbe71322db3">&#9670;&nbsp;</a></span>setSerial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbguard::Device::setSerial </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>serial_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets device serial number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serial_number</td><td>Serial number to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>If given <code>serial_number</code> is bigger then <code>USB_GENERIC_STRING_MAX_LENGTH</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e348ec0b621bf268fb2890b63b38fda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e348ec0b621bf268fb2890b63b38fda">&#9670;&nbsp;</a></span>setTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbguard::Device::setTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fc">Rule::Target</a>&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets given target for this device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Target to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fc">Target</a> </dd></dl>

</div>
</div>
<a id="a470991255efde5361154ba294e70fad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a470991255efde5361154ba294e70fad5">&#9670;&nbsp;</a></span>updateHash() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbguard::Device::updateHash </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hashes given data and creates new hash value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to data to hash. </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to hash. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba08252ef70bc19847b2298855b4cd4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba08252ef70bc19847b2298855b4cd4f">&#9670;&nbsp;</a></span>updateHash() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbguard::Device::updateHash </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>descriptor_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>expected_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hashes given descriptor stream and creates new hash value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descriptor_stream</td><td>Descriptor stream to hash. </td></tr>
    <tr><td class="paramname">expected_size</td><td>Expected number of bytes to hash. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Exception</td><td>If descriptor stream didnt return expected amount of data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Device_8hpp_source.html">Device.hpp</a></li>
<li>Device.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
