<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>USBGuard: usbguard::IPCClient Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="usbguard-logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">USBGuard
   </div>
   <div id="projectbrief">Software framework that protects your computer against rogue USB devices by implementing basic whitelisting and blacklisting capabilities.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>usbguard</b></li><li class="navelem"><a class="el" href="classusbguard_1_1IPCClient.html">IPCClient</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classusbguard_1_1IPCClient-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">usbguard::IPCClient Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Communicates with USBGuard service (<a class="el" href="classusbguard_1_1IPCServer.html">IPCServer</a>).  
 <a href="classusbguard_1_1IPCClient.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="IPCClient_8hpp_source.html">IPCClient.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for usbguard::IPCClient:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classusbguard_1_1IPCClient.png" usemap="#usbguard::IPCClient_map" alt=""/>
  <map id="usbguard::IPCClient_map" name="usbguard::IPCClient_map">
<area href="classusbguard_1_1Interface.html" title="Allows to receive signals and to communicate with the USBGuard daemon." alt="usbguard::Interface" shape="rect" coords="0,0,123,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abf5cab47062c51a1bb3bb9b1e59864ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1IPCClient.html#abf5cab47062c51a1bb3bb9b1e59864ab">IPCClient</a> (bool connected=false)</td></tr>
<tr class="memdesc:abf5cab47062c51a1bb3bb9b1e59864ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs IPC client.  <a href="#abf5cab47062c51a1bb3bb9b1e59864ab">More...</a><br /></td></tr>
<tr class="separator:abf5cab47062c51a1bb3bb9b1e59864ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7d80982da17fac0fc0aaa318eb0119"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1IPCClient.html#ade7d80982da17fac0fc0aaa318eb0119">~IPCClient</a> ()</td></tr>
<tr class="memdesc:ade7d80982da17fac0fc0aaa318eb0119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects from an USBGuard <a class="el" href="classusbguard_1_1IPCServer.html">IPC service</a> and destructs this object.  <a href="#ade7d80982da17fac0fc0aaa318eb0119">More...</a><br /></td></tr>
<tr class="separator:ade7d80982da17fac0fc0aaa318eb0119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e1209f92913040941a2137a0f7dd41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1IPCClient.html#a96e1209f92913040941a2137a0f7dd41">connect</a> ()</td></tr>
<tr class="memdesc:a96e1209f92913040941a2137a0f7dd41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates connection to an USBGuard <a class="el" href="classusbguard_1_1IPCServer.html">IPC service</a>.  <a href="#a96e1209f92913040941a2137a0f7dd41">More...</a><br /></td></tr>
<tr class="separator:a96e1209f92913040941a2137a0f7dd41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca94fa2d54aa53ccc01ed2370afafd2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1IPCClient.html#aca94fa2d54aa53ccc01ed2370afafd2b">disconnect</a> ()</td></tr>
<tr class="memdesc:aca94fa2d54aa53ccc01ed2370afafd2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects from an USBGuard <a class="el" href="classusbguard_1_1IPCServer.html">IPC service</a>.  <a href="#aca94fa2d54aa53ccc01ed2370afafd2b">More...</a><br /></td></tr>
<tr class="separator:aca94fa2d54aa53ccc01ed2370afafd2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4601a1e821aa815c6a9f3716582e93"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1IPCClient.html#a9b4601a1e821aa815c6a9f3716582e93">isConnected</a> () const</td></tr>
<tr class="memdesc:a9b4601a1e821aa815c6a9f3716582e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether client is connected to USBGuard <a class="el" href="classusbguard_1_1IPCServer.html">IPC service</a>.  <a href="#a9b4601a1e821aa815c6a9f3716582e93">More...</a><br /></td></tr>
<tr class="separator:a9b4601a1e821aa815c6a9f3716582e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f9013372ed4ac9ded0155136aa3698"><td class="memItemLeft" align="right" valign="top"><a id="a11f9013372ed4ac9ded0155136aa3698"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1IPCClient.html#a11f9013372ed4ac9ded0155136aa3698">wait</a> ()</td></tr>
<tr class="memdesc:a11f9013372ed4ac9ded0155136aa3698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for IPC client main loop to finish its work. <br /></td></tr>
<tr class="separator:a11f9013372ed4ac9ded0155136aa3698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ccb1a393f7c1298b03eb7de8573e6d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1IPCClient.html#a55ccb1a393f7c1298b03eb7de8573e6d">setParameter</a> (const std::string &amp;name, const std::string &amp;value) override</td></tr>
<tr class="memdesc:a55ccb1a393f7c1298b03eb7de8573e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set value of a runtime parameter.  <a href="#a55ccb1a393f7c1298b03eb7de8573e6d">More...</a><br /></td></tr>
<tr class="separator:a55ccb1a393f7c1298b03eb7de8573e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac148ce9b78dac7f13ca5a3b9fd04707c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1IPCClient.html#ac148ce9b78dac7f13ca5a3b9fd04707c">getParameter</a> (const std::string &amp;name) override</td></tr>
<tr class="memdesc:ac148ce9b78dac7f13ca5a3b9fd04707c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get value of a runtime parameter.  <a href="#ac148ce9b78dac7f13ca5a3b9fd04707c">More...</a><br /></td></tr>
<tr class="separator:ac148ce9b78dac7f13ca5a3b9fd04707c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614406e8828a6b38952fe6dec68e13b7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1IPCClient.html#a614406e8828a6b38952fe6dec68e13b7">appendRule</a> (const std::string &amp;rule_spec, uint32_t parent_id, bool permanent) override</td></tr>
<tr class="memdesc:a614406e8828a6b38952fe6dec68e13b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a new rule to the current policy.  <a href="#a614406e8828a6b38952fe6dec68e13b7">More...</a><br /></td></tr>
<tr class="separator:a614406e8828a6b38952fe6dec68e13b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd5109e070a4d1a7e7fde9ffa698691"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1IPCClient.html#a0cd5109e070a4d1a7e7fde9ffa698691">removeRule</a> (uint32_t id) override</td></tr>
<tr class="memdesc:a0cd5109e070a4d1a7e7fde9ffa698691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a rule from the current policy.  <a href="#a0cd5109e070a4d1a7e7fde9ffa698691">More...</a><br /></td></tr>
<tr class="separator:a0cd5109e070a4d1a7e7fde9ffa698691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6824e6450a2d316cf16825d9b4c5ce"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classusbguard_1_1Rule.html">Rule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1IPCClient.html#a4d6824e6450a2d316cf16825d9b4c5ce">listRules</a> (const std::string &amp;label) override</td></tr>
<tr class="memdesc:a4d6824e6450a2d316cf16825d9b4c5ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">List the current rule set (policy) used by the USBGuard daemon.  <a href="#a4d6824e6450a2d316cf16825d9b4c5ce">More...</a><br /></td></tr>
<tr class="separator:a4d6824e6450a2d316cf16825d9b4c5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4567c4a2008774064bae549f676414"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classusbguard_1_1Rule.html">Rule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1IPCClient.html#ada4567c4a2008774064bae549f676414">listRules</a> ()</td></tr>
<tr class="memdesc:ada4567c4a2008774064bae549f676414"><td class="mdescLeft">&#160;</td><td class="mdescRight">List the current rule set (policy) used by the USBGuard daemon.  <a href="#ada4567c4a2008774064bae549f676414">More...</a><br /></td></tr>
<tr class="separator:ada4567c4a2008774064bae549f676414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742c9f432bca7278311be92204e10e08"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1IPCClient.html#a742c9f432bca7278311be92204e10e08">applyDevicePolicy</a> (uint32_t id, <a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fc">Rule::Target</a> target, bool permanent) override</td></tr>
<tr class="memdesc:a742c9f432bca7278311be92204e10e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply an authorization target to a device.  <a href="#a742c9f432bca7278311be92204e10e08">More...</a><br /></td></tr>
<tr class="separator:a742c9f432bca7278311be92204e10e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559a2d73153d63817275d4c6e2413ab1"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classusbguard_1_1Rule.html">Rule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1IPCClient.html#a559a2d73153d63817275d4c6e2413ab1">listDevices</a> (const std::string &amp;query) override</td></tr>
<tr class="memdesc:a559a2d73153d63817275d4c6e2413ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">List devices that match the specified query.  <a href="#a559a2d73153d63817275d4c6e2413ab1">More...</a><br /></td></tr>
<tr class="separator:a559a2d73153d63817275d4c6e2413ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d40889fd93120e23bd3ecb939db97c8"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classusbguard_1_1Rule.html">Rule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1IPCClient.html#a0d40889fd93120e23bd3ecb939db97c8">listDevices</a> ()</td></tr>
<tr class="memdesc:a0d40889fd93120e23bd3ecb939db97c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">List all devices recognized by USBGuard daemon.  <a href="#a0d40889fd93120e23bd3ecb939db97c8">More...</a><br /></td></tr>
<tr class="separator:a0d40889fd93120e23bd3ecb939db97c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fab90a69f5594855b8f5b076e300f09"><td class="memItemLeft" align="right" valign="top"><a id="a2fab90a69f5594855b8f5b076e300f09"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1IPCClient.html#a2fab90a69f5594855b8f5b076e300f09">IPCConnected</a> ()</td></tr>
<tr class="memdesc:a2fab90a69f5594855b8f5b076e300f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines algorithm to perform in the case of IPC connection. <br /></td></tr>
<tr class="separator:a2fab90a69f5594855b8f5b076e300f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19757cdbde3369d7880ecdc0728d7752"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1IPCClient.html#a19757cdbde3369d7880ecdc0728d7752">IPCDisconnected</a> (bool exception_initiated, const <a class="el" href="classusbguard_1_1IPCException.html">IPCException</a> &amp;exception)</td></tr>
<tr class="memdesc:a19757cdbde3369d7880ecdc0728d7752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines algorithm to perform in the case of IPC disconnection.  <a href="#a19757cdbde3369d7880ecdc0728d7752">More...</a><br /></td></tr>
<tr class="separator:a19757cdbde3369d7880ecdc0728d7752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1911139040039d0655f0fecaf1580808"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1IPCClient.html#a1911139040039d0655f0fecaf1580808">DevicePresenceChanged</a> (uint32_t id, <a class="el" href="classusbguard_1_1DeviceManager.html#a286e8dedc116284751c3f59379207335">DeviceManager::EventType</a> event, <a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fc">Rule::Target</a> target, const std::string &amp;device_rule) override</td></tr>
<tr class="memdesc:a1911139040039d0655f0fecaf1580808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines algorithm to perform in the case that USB device presence has been changed.  <a href="#a1911139040039d0655f0fecaf1580808">More...</a><br /></td></tr>
<tr class="separator:a1911139040039d0655f0fecaf1580808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e23439463cd197fcce9342569c5f3c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1IPCClient.html#af0e23439463cd197fcce9342569c5f3c">DevicePolicyChanged</a> (uint32_t id, <a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fc">Rule::Target</a> target_old, <a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fc">Rule::Target</a> target_new, const std::string &amp;device_rule, uint32_t rule_id) override</td></tr>
<tr class="memdesc:af0e23439463cd197fcce9342569c5f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines algorithm to perform in the case that USB device authorization target has been changed.  <a href="#af0e23439463cd197fcce9342569c5f3c">More...</a><br /></td></tr>
<tr class="separator:af0e23439463cd197fcce9342569c5f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23891d3007d194c63baef67164672ded"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1IPCClient.html#a23891d3007d194c63baef67164672ded">PropertyParameterChanged</a> (const std::string &amp;name, const std::string &amp;value_old, const std::string &amp;value_new) override</td></tr>
<tr class="memdesc:a23891d3007d194c63baef67164672ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines algorithm to perform in the case that property parameter has been changed.  <a href="#a23891d3007d194c63baef67164672ded">More...</a><br /></td></tr>
<tr class="separator:a23891d3007d194c63baef67164672ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade8e1a8c8a304ceb853f097169ff876"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1IPCClient.html#aade8e1a8c8a304ceb853f097169ff876">ExceptionMessage</a> (const std::string &amp;context, const std::string &amp;object, const std::string &amp;reason) override</td></tr>
<tr class="memdesc:aade8e1a8c8a304ceb853f097169ff876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines algorithm to perform in the case that exception has arose.  <a href="#aade8e1a8c8a304ceb853f097169ff876">More...</a><br /></td></tr>
<tr class="separator:aade8e1a8c8a304ceb853f097169ff876"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Communicates with USBGuard service (<a class="el" href="classusbguard_1_1IPCServer.html">IPCServer</a>). </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abf5cab47062c51a1bb3bb9b1e59864ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf5cab47062c51a1bb3bb9b1e59864ab">&#9670;&nbsp;</a></span>IPCClient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">usbguard::IPCClient::IPCClient </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>connected</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs IPC client. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">connected</td><td>If this flag is set to true, then it tries to connect to USBGuard <a class="el" href="classusbguard_1_1IPCServer.html">IPC service</a> and starts IPC client main loop. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusbguard_1_1IPCClient.html#a96e1209f92913040941a2137a0f7dd41">connect()</a> </dd></dl>

</div>
</div>
<a id="ade7d80982da17fac0fc0aaa318eb0119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade7d80982da17fac0fc0aaa318eb0119">&#9670;&nbsp;</a></span>~IPCClient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">usbguard::IPCClient::~IPCClient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disconnects from an USBGuard <a class="el" href="classusbguard_1_1IPCServer.html">IPC service</a> and destructs this object. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusbguard_1_1IPCClient.html#aca94fa2d54aa53ccc01ed2370afafd2b">disconnect()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a614406e8828a6b38952fe6dec68e13b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614406e8828a6b38952fe6dec68e13b7">&#9670;&nbsp;</a></span>appendRule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t usbguard::IPCClient::appendRule </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rule_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>parent_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>permanent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a new rule to the current policy. </p>
<p>Using the <code>parent_id</code> parameter, the rule can be inserted anywhere in the policy, not only at the end. When the rule is successfully appended, the ID assigned to the new rule is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rule_spec</td><td>The rule that should be appended to the policy. </td></tr>
    <tr><td class="paramname">parent_id</td><td>Rule ID of the parent rule. </td></tr>
    <tr><td class="paramname">permanent</td><td>Determines whether the rule will be added to the policy file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rule ID assigned to the successfully appended rule. </dd></dl>

<p>Implements <a class="el" href="classusbguard_1_1Interface.html#a673c55ad87353e71a0008ec43aefa770">usbguard::Interface</a>.</p>

</div>
</div>
<a id="a742c9f432bca7278311be92204e10e08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a742c9f432bca7278311be92204e10e08">&#9670;&nbsp;</a></span>applyDevicePolicy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t usbguard::IPCClient::applyDevicePolicy </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fc">Rule::Target</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>permanent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply an authorization target to a device. </p>
<p>If the <code>permanent</code> flag is set to true, a rule will be appended to the policy or an existing device rule will be modified in order to permanently store the authorization decision. Successful execution of this method will cause the DevicePolicyChanged signal to be broadcasted if the device authorization target was different then the applied target.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Device ID of the device to authorize. </td></tr>
    <tr><td class="paramname">target</td><td>Device authorization target. </td></tr>
    <tr><td class="paramname">permanent</td><td>Boolean flag specifying whether an allow rule should be appended to the policy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <code>permanent</code> was set to true, the method will return an ID of the rule that was modified or created because of this request. </dd></dl>

<p>Implements <a class="el" href="classusbguard_1_1Interface.html#a9a45300fca95abeb65fb36001c921983">usbguard::Interface</a>.</p>

</div>
</div>
<a id="a96e1209f92913040941a2137a0f7dd41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96e1209f92913040941a2137a0f7dd41">&#9670;&nbsp;</a></span>connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbguard::IPCClient::connect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates connection to an USBGuard <a class="el" href="classusbguard_1_1IPCServer.html">IPC service</a>. </p>
<p>Starts IPC client main loop.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ErrnoException</td><td>If there is no service called "usbguard". </td></tr>
    <tr><td class="paramname">Exception</td><td>If we received bad file descriptor to poll. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0e23439463cd197fcce9342569c5f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e23439463cd197fcce9342569c5f3c">&#9670;&nbsp;</a></span>DevicePolicyChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void usbguard::IPCClient::DevicePolicyChanged </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fc">Rule::Target</a>&#160;</td>
          <td class="paramname"><em>target_old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fc">Rule::Target</a>&#160;</td>
          <td class="paramname"><em>target_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>device_rule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rule_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines algorithm to perform in the case that USB device authorization target has been changed. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusbguard_1_1Interface.html#acdd469fc8af007d45f2c9280ac2adbe8">DevicePolicyChanged()</a> </dd></dl>

<p>Implements <a class="el" href="classusbguard_1_1Interface.html#acdd469fc8af007d45f2c9280ac2adbe8">usbguard::Interface</a>.</p>

</div>
</div>
<a id="a1911139040039d0655f0fecaf1580808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1911139040039d0655f0fecaf1580808">&#9670;&nbsp;</a></span>DevicePresenceChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void usbguard::IPCClient::DevicePresenceChanged </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classusbguard_1_1DeviceManager.html#a286e8dedc116284751c3f59379207335">DeviceManager::EventType</a>&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fc">Rule::Target</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>device_rule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines algorithm to perform in the case that USB device presence has been changed. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusbguard_1_1Interface.html#a92dc6c350d36d1821ccfe05c09d5737f">DevicePresenceChanged()</a> </dd></dl>

<p>Implements <a class="el" href="classusbguard_1_1Interface.html#a92dc6c350d36d1821ccfe05c09d5737f">usbguard::Interface</a>.</p>

</div>
</div>
<a id="aca94fa2d54aa53ccc01ed2370afafd2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca94fa2d54aa53ccc01ed2370afafd2b">&#9670;&nbsp;</a></span>disconnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbguard::IPCClient::disconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disconnects from an USBGuard <a class="el" href="classusbguard_1_1IPCServer.html">IPC service</a>. </p>
<p>Stops IPC client main loop. </p>

</div>
</div>
<a id="aade8e1a8c8a304ceb853f097169ff876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aade8e1a8c8a304ceb853f097169ff876">&#9670;&nbsp;</a></span>ExceptionMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void usbguard::IPCClient::ExceptionMessage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines algorithm to perform in the case that exception has arose. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusbguard_1_1Interface.html#a8ca5e91eaee2c3a3168bb384e184af2d">ExceptionMessage()</a> </dd></dl>

<p>Implements <a class="el" href="classusbguard_1_1Interface.html#a8ca5e91eaee2c3a3168bb384e184af2d">usbguard::Interface</a>.</p>

</div>
</div>
<a id="ac148ce9b78dac7f13ca5a3b9fd04707c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac148ce9b78dac7f13ca5a3b9fd04707c">&#9670;&nbsp;</a></span>getParameter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string usbguard::IPCClient::getParameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get value of a runtime parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of runtime parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of runtime parameter. </dd></dl>

<p>Implements <a class="el" href="classusbguard_1_1Interface.html#aa105283a5faa9d2100f5d59bf3dedcf7">usbguard::Interface</a>.</p>

</div>
</div>
<a id="a19757cdbde3369d7880ecdc0728d7752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19757cdbde3369d7880ecdc0728d7752">&#9670;&nbsp;</a></span>IPCDisconnected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void usbguard::IPCClient::IPCDisconnected </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exception_initiated</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classusbguard_1_1IPCException.html">IPCException</a> &amp;&#160;</td>
          <td class="paramname"><em>exception</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines algorithm to perform in the case of IPC disconnection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exception_initiated</td><td>Determines whether disconnection was caused by an exception. </td></tr>
    <tr><td class="paramname">exception</td><td>Exception that caused the disconnection. Exception is valid only if <code>exception_initiated</code> is set to true. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b4601a1e821aa815c6a9f3716582e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b4601a1e821aa815c6a9f3716582e93">&#9670;&nbsp;</a></span>isConnected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool usbguard::IPCClient::isConnected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether client is connected to USBGuard <a class="el" href="classusbguard_1_1IPCServer.html">IPC service</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>True if this client is connected to USBGuard IPC service, false otherwise. </dd></dl>

</div>
</div>
<a id="a559a2d73153d63817275d4c6e2413ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a559a2d73153d63817275d4c6e2413ab1">&#9670;&nbsp;</a></span>listDevices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classusbguard_1_1Rule.html">Rule</a> &gt; usbguard::IPCClient::listDevices </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>query</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List devices that match the specified query. </p>
<p>The query uses the rule language syntax and the devices are returned as device specific rules. The target in each rule represents the current authorization state of the device. Order of the returned devices is not defined and should not be relied upon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>Query in the rule language syntax used to match devices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of device specific rules that match the query. </dd></dl>

<p>Implements <a class="el" href="classusbguard_1_1Interface.html#a6192acda3e39eb71880354598cb88b29">usbguard::Interface</a>.</p>

</div>
</div>
<a id="a0d40889fd93120e23bd3ecb939db97c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d40889fd93120e23bd3ecb939db97c8">&#9670;&nbsp;</a></span>listDevices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classusbguard_1_1Rule.html">Rule</a>&gt; usbguard::IPCClient::listDevices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List all devices recognized by USBGuard daemon. </p>
<dl class="section note"><dt>Note</dt><dd>Left for compatibility.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of device specific rules. </dd></dl>

</div>
</div>
<a id="a4d6824e6450a2d316cf16825d9b4c5ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d6824e6450a2d316cf16825d9b4c5ce">&#9670;&nbsp;</a></span>listRules() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classusbguard_1_1Rule.html">Rule</a> &gt; usbguard::IPCClient::listRules </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List the current rule set (policy) used by the USBGuard daemon. </p>
<p>The rules are returned in the same order as they are evaluated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>Query used for matching rules. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of rules. </dd></dl>

<p>Implements <a class="el" href="classusbguard_1_1Interface.html#a3cd24f2468133c8718d5b028cca4c801">usbguard::Interface</a>.</p>

</div>
</div>
<a id="ada4567c4a2008774064bae549f676414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada4567c4a2008774064bae549f676414">&#9670;&nbsp;</a></span>listRules() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classusbguard_1_1Rule.html">Rule</a>&gt; usbguard::IPCClient::listRules </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List the current rule set (policy) used by the USBGuard daemon. </p>
<p>The rules are returned in the same order as they are evaluated.</p>
<dl class="section return"><dt>Returns</dt><dd>Vector of rules. </dd></dl>

</div>
</div>
<a id="a23891d3007d194c63baef67164672ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23891d3007d194c63baef67164672ded">&#9670;&nbsp;</a></span>PropertyParameterChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void usbguard::IPCClient::PropertyParameterChanged </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value_old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value_new</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines algorithm to perform in the case that property parameter has been changed. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classusbguard_1_1Interface.html#a671eed8ebea79f8f6f9a6dfc39e26253">PropertyParameterChanged()</a> </dd></dl>

<p>Implements <a class="el" href="classusbguard_1_1Interface.html#a671eed8ebea79f8f6f9a6dfc39e26253">usbguard::Interface</a>.</p>

</div>
</div>
<a id="a0cd5109e070a4d1a7e7fde9ffa698691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cd5109e070a4d1a7e7fde9ffa698691">&#9670;&nbsp;</a></span>removeRule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void usbguard::IPCClient::removeRule </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a rule from the current policy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The rule ID of the rule to be removed. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classusbguard_1_1Interface.html#a7a369e492afb793778a748182c78501d">usbguard::Interface</a>.</p>

</div>
</div>
<a id="a55ccb1a393f7c1298b03eb7de8573e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55ccb1a393f7c1298b03eb7de8573e6d">&#9670;&nbsp;</a></span>setParameter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string usbguard::IPCClient::setParameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set value of a runtime parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of runtime parameter. </td></tr>
    <tr><td class="paramname">value</td><td>Value of runtime parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Previous value of runtime parameter. </dd></dl>

<p>Implements <a class="el" href="classusbguard_1_1Interface.html#a38d65c802d84b9ce6bb979fd5690d1ee">usbguard::Interface</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="IPCClient_8hpp_source.html">IPCClient.hpp</a></li>
<li>IPCClient.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
