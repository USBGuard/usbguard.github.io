<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>USBGuard: usbguard::Interface Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="usbguard-logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">USBGuard
   </div>
   <div id="projectbrief">Software framework that protects your computer against rogue USB devices by implementing basic whitelisting and blacklisting capabilities.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>usbguard</b></li><li class="navelem"><a class="el" href="classusbguard_1_1Interface.html">Interface</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classusbguard_1_1Interface-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">usbguard::Interface Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Allows to receive signals and to communicate with the USBGuard daemon.  
 <a href="classusbguard_1_1Interface.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Interface_8hpp_source.html">Interface.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for usbguard::Interface:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classusbguard_1_1Interface.png" usemap="#usbguard::Interface_map" alt=""/>
  <map id="usbguard::Interface_map" name="usbguard::Interface_map">
<area href="classusbguard_1_1IPCClient.html" title="Communicates with USBGuard service (IPCServer)." alt="usbguard::IPCClient" shape="rect" coords="0,56,130,80"/>
<area href="classusbguard_1_1IPCServer.html" title="Receives messages from IPC clients. Provides USBGuard service." alt="usbguard::IPCServer" shape="rect" coords="140,56,270,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a38d65c802d84b9ce6bb979fd5690d1ee"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Interface.html#a38d65c802d84b9ce6bb979fd5690d1ee">setParameter</a> (const std::string &amp;name, const std::string &amp;value)=0</td></tr>
<tr class="memdesc:a38d65c802d84b9ce6bb979fd5690d1ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set value of a runtime parameter.  <a href="#a38d65c802d84b9ce6bb979fd5690d1ee">More...</a><br /></td></tr>
<tr class="separator:a38d65c802d84b9ce6bb979fd5690d1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa105283a5faa9d2100f5d59bf3dedcf7"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Interface.html#aa105283a5faa9d2100f5d59bf3dedcf7">getParameter</a> (const std::string &amp;name)=0</td></tr>
<tr class="memdesc:aa105283a5faa9d2100f5d59bf3dedcf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get value of a runtime parameter.  <a href="#aa105283a5faa9d2100f5d59bf3dedcf7">More...</a><br /></td></tr>
<tr class="separator:aa105283a5faa9d2100f5d59bf3dedcf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673c55ad87353e71a0008ec43aefa770"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Interface.html#a673c55ad87353e71a0008ec43aefa770">appendRule</a> (const std::string &amp;rule_spec, uint32_t parent_id, bool permanent)=0</td></tr>
<tr class="memdesc:a673c55ad87353e71a0008ec43aefa770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a new rule to the current policy.  <a href="#a673c55ad87353e71a0008ec43aefa770">More...</a><br /></td></tr>
<tr class="separator:a673c55ad87353e71a0008ec43aefa770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a369e492afb793778a748182c78501d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Interface.html#a7a369e492afb793778a748182c78501d">removeRule</a> (uint32_t id)=0</td></tr>
<tr class="memdesc:a7a369e492afb793778a748182c78501d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a rule from the current policy.  <a href="#a7a369e492afb793778a748182c78501d">More...</a><br /></td></tr>
<tr class="separator:a7a369e492afb793778a748182c78501d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd24f2468133c8718d5b028cca4c801"><td class="memItemLeft" align="right" valign="top">virtual const std::vector&lt; <a class="el" href="classusbguard_1_1Rule.html">Rule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Interface.html#a3cd24f2468133c8718d5b028cca4c801">listRules</a> (const std::string &amp;query)=0</td></tr>
<tr class="memdesc:a3cd24f2468133c8718d5b028cca4c801"><td class="mdescLeft">&#160;</td><td class="mdescRight">List the current rule set (policy) used by the USBGuard daemon.  <a href="#a3cd24f2468133c8718d5b028cca4c801">More...</a><br /></td></tr>
<tr class="separator:a3cd24f2468133c8718d5b028cca4c801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a45300fca95abeb65fb36001c921983"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Interface.html#a9a45300fca95abeb65fb36001c921983">applyDevicePolicy</a> (uint32_t id, <a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fc">Rule::Target</a> target, bool permanent)=0</td></tr>
<tr class="memdesc:a9a45300fca95abeb65fb36001c921983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply an authorization target to a device.  <a href="#a9a45300fca95abeb65fb36001c921983">More...</a><br /></td></tr>
<tr class="separator:a9a45300fca95abeb65fb36001c921983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6192acda3e39eb71880354598cb88b29"><td class="memItemLeft" align="right" valign="top">virtual const std::vector&lt; <a class="el" href="classusbguard_1_1Rule.html">Rule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Interface.html#a6192acda3e39eb71880354598cb88b29">listDevices</a> (const std::string &amp;query)=0</td></tr>
<tr class="memdesc:a6192acda3e39eb71880354598cb88b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">List devices that match the specified query.  <a href="#a6192acda3e39eb71880354598cb88b29">More...</a><br /></td></tr>
<tr class="separator:a6192acda3e39eb71880354598cb88b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92dc6c350d36d1821ccfe05c09d5737f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Interface.html#a92dc6c350d36d1821ccfe05c09d5737f">DevicePresenceChanged</a> (uint32_t id, <a class="el" href="classusbguard_1_1DeviceManager.html#a286e8dedc116284751c3f59379207335">DeviceManager::EventType</a> event, <a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fc">Rule::Target</a> target, const std::string &amp;device_rule)=0</td></tr>
<tr class="memdesc:a92dc6c350d36d1821ccfe05c09d5737f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify that a USB device was already present when USBGuard was started.  <a href="#a92dc6c350d36d1821ccfe05c09d5737f">More...</a><br /></td></tr>
<tr class="separator:a92dc6c350d36d1821ccfe05c09d5737f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd469fc8af007d45f2c9280ac2adbe8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Interface.html#acdd469fc8af007d45f2c9280ac2adbe8">DevicePolicyChanged</a> (uint32_t id, <a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fc">Rule::Target</a> target_old, <a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fc">Rule::Target</a> target_new, const std::string &amp;device_rule, uint32_t rule_id)=0</td></tr>
<tr class="memdesc:acdd469fc8af007d45f2c9280ac2adbe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify about a change of a USB device authorization target.  <a href="#acdd469fc8af007d45f2c9280ac2adbe8">More...</a><br /></td></tr>
<tr class="separator:acdd469fc8af007d45f2c9280ac2adbe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671eed8ebea79f8f6f9a6dfc39e26253"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Interface.html#a671eed8ebea79f8f6f9a6dfc39e26253">PropertyParameterChanged</a> (const std::string &amp;name, const std::string &amp;value_old, const std::string &amp;value_new)=0</td></tr>
<tr class="memdesc:a671eed8ebea79f8f6f9a6dfc39e26253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify about a change of a property parameter.  <a href="#a671eed8ebea79f8f6f9a6dfc39e26253">More...</a><br /></td></tr>
<tr class="separator:a671eed8ebea79f8f6f9a6dfc39e26253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca5e91eaee2c3a3168bb384e184af2d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbguard_1_1Interface.html#a8ca5e91eaee2c3a3168bb384e184af2d">ExceptionMessage</a> (const std::string &amp;context, const std::string &amp;object, const std::string &amp;reason)=0</td></tr>
<tr class="memdesc:a8ca5e91eaee2c3a3168bb384e184af2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify about an exception.  <a href="#a8ca5e91eaee2c3a3168bb384e184af2d">More...</a><br /></td></tr>
<tr class="separator:a8ca5e91eaee2c3a3168bb384e184af2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Allows to receive signals and to communicate with the USBGuard daemon. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a673c55ad87353e71a0008ec43aefa770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a673c55ad87353e71a0008ec43aefa770">&#9670;&nbsp;</a></span>appendRule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t usbguard::Interface::appendRule </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rule_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>parent_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>permanent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a new rule to the current policy. </p>
<p>Using the <code>parent_id</code> parameter, the rule can be inserted anywhere in the policy, not only at the end. When the rule is successfully appended, the ID assigned to the new rule is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rule_spec</td><td>The rule that should be appended to the policy. </td></tr>
    <tr><td class="paramname">parent_id</td><td>Rule ID of the parent rule. </td></tr>
    <tr><td class="paramname">permanent</td><td>Determines whether the rule will be added to the policy file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rule ID assigned to the successfully appended rule. </dd></dl>

<p>Implemented in <a class="el" href="classusbguard_1_1IPCClient.html#a614406e8828a6b38952fe6dec68e13b7">usbguard::IPCClient</a>.</p>

</div>
</div>
<a id="a9a45300fca95abeb65fb36001c921983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a45300fca95abeb65fb36001c921983">&#9670;&nbsp;</a></span>applyDevicePolicy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t usbguard::Interface::applyDevicePolicy </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fc">Rule::Target</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>permanent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply an authorization target to a device. </p>
<p>If the <code>permanent</code> flag is set to true, a rule will be appended to the policy or an existing device rule will be modified in order to permanently store the authorization decision. Successful execution of this method will cause the DevicePolicyChanged signal to be broadcasted if the device authorization target was different then the applied target.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Device ID of the device to authorize. </td></tr>
    <tr><td class="paramname">target</td><td>Device authorization target. </td></tr>
    <tr><td class="paramname">permanent</td><td>Boolean flag specifying whether an allow rule should be appended to the policy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <code>permanent</code> was set to true, the method will return an ID of the rule that was modified or created because of this request. </dd></dl>

<p>Implemented in <a class="el" href="classusbguard_1_1IPCClient.html#a742c9f432bca7278311be92204e10e08">usbguard::IPCClient</a>.</p>

</div>
</div>
<a id="acdd469fc8af007d45f2c9280ac2adbe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdd469fc8af007d45f2c9280ac2adbe8">&#9670;&nbsp;</a></span>DevicePolicyChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void usbguard::Interface::DevicePolicyChanged </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fc">Rule::Target</a>&#160;</td>
          <td class="paramname"><em>target_old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fc">Rule::Target</a>&#160;</td>
          <td class="paramname"><em>target_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>device_rule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rule_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify about a change of a USB device authorization target. </p>
<p>The device attribute dictionary contains the following attributes:</p><ul>
<li>id (the USB device ID in the form VID:PID)</li>
<li>name</li>
<li>serial</li>
<li>via-port</li>
<li>hash</li>
<li>parent-hash</li>
<li>with-interface</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>ID of the device. </td></tr>
    <tr><td class="paramname">target_old</td><td>Previous authorization target. </td></tr>
    <tr><td class="paramname">target_new</td><td>Current authorization target. </td></tr>
    <tr><td class="paramname">device_rule</td><td>Device specific rule. </td></tr>
    <tr><td class="paramname">rule_id</td><td>Rule ID of the matched rule. Otherwise a reserved rule ID value is used. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classusbguard_1_1IPCServer.html#a8044c487864e848f1d1d08c6e7fcad81">usbguard::IPCServer</a>, and <a class="el" href="classusbguard_1_1IPCClient.html#af0e23439463cd197fcce9342569c5f3c">usbguard::IPCClient</a>.</p>

</div>
</div>
<a id="a92dc6c350d36d1821ccfe05c09d5737f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92dc6c350d36d1821ccfe05c09d5737f">&#9670;&nbsp;</a></span>DevicePresenceChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void usbguard::Interface::DevicePresenceChanged </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classusbguard_1_1DeviceManager.html#a286e8dedc116284751c3f59379207335">DeviceManager::EventType</a>&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classusbguard_1_1Rule.html#a99589e901823bb3e0c1ca50d83e256fc">Rule::Target</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>device_rule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify that a USB device was already present when USBGuard was started. </p>
<p>The device attribute dictionary contains the following attributes:</p><ul>
<li>id (the USB device ID in the form VID:PID)</li>
<li>name</li>
<li>serial</li>
<li>via-port</li>
<li>hash</li>
<li>parent-hash</li>
<li>with-interface</li>
</ul>
<p>The USB interface types are represented as strings of the form AA:BB:CC, where AA, BB and CC are hexadecimal numbers representing the class, subclass and protocol of the interface as defined by the USB standard.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>ID of the device. </td></tr>
    <tr><td class="paramname">event</td><td>Type of the presence change event. </td></tr>
    <tr><td class="paramname">target</td><td>The current authorization target of the device. </td></tr>
    <tr><td class="paramname">device_rule</td><td>Device specific rule. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classusbguard_1_1IPCServer.html#aa6fe4b0e04f4d27acb4bfcd6e66af9b0">usbguard::IPCServer</a>, and <a class="el" href="classusbguard_1_1IPCClient.html#a1911139040039d0655f0fecaf1580808">usbguard::IPCClient</a>.</p>

</div>
</div>
<a id="a8ca5e91eaee2c3a3168bb384e184af2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ca5e91eaee2c3a3168bb384e184af2d">&#9670;&nbsp;</a></span>ExceptionMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void usbguard::Interface::ExceptionMessage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify about an exception. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Description or identifier of the exception context. </td></tr>
    <tr><td class="paramname">object</td><td>Description or identifier of the object which caused the exception. </td></tr>
    <tr><td class="paramname">reason</td><td>Reason explaining why the exception was generated. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classusbguard_1_1IPCServer.html#a4f678ebcb28b16f4ec6c840179a31263">usbguard::IPCServer</a>, and <a class="el" href="classusbguard_1_1IPCClient.html#aade8e1a8c8a304ceb853f097169ff876">usbguard::IPCClient</a>.</p>

</div>
</div>
<a id="aa105283a5faa9d2100f5d59bf3dedcf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa105283a5faa9d2100f5d59bf3dedcf7">&#9670;&nbsp;</a></span>getParameter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string usbguard::Interface::getParameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get value of a runtime parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of runtime parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of runtime parameter. </dd></dl>

<p>Implemented in <a class="el" href="classusbguard_1_1IPCClient.html#ac148ce9b78dac7f13ca5a3b9fd04707c">usbguard::IPCClient</a>.</p>

</div>
</div>
<a id="a6192acda3e39eb71880354598cb88b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6192acda3e39eb71880354598cb88b29">&#9670;&nbsp;</a></span>listDevices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::vector&lt;<a class="el" href="classusbguard_1_1Rule.html">Rule</a>&gt; usbguard::Interface::listDevices </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>query</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List devices that match the specified query. </p>
<p>The query uses the rule language syntax and the devices are returned as device specific rules. The target in each rule represents the current authorization state of the device. Order of the returned devices is not defined and should not be relied upon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>Query in the rule language syntax used to match devices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of device specific rules that match the query. </dd></dl>

<p>Implemented in <a class="el" href="classusbguard_1_1IPCClient.html#a559a2d73153d63817275d4c6e2413ab1">usbguard::IPCClient</a>.</p>

</div>
</div>
<a id="a3cd24f2468133c8718d5b028cca4c801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cd24f2468133c8718d5b028cca4c801">&#9670;&nbsp;</a></span>listRules()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::vector&lt;<a class="el" href="classusbguard_1_1Rule.html">Rule</a>&gt; usbguard::Interface::listRules </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>query</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List the current rule set (policy) used by the USBGuard daemon. </p>
<p>The rules are returned in the same order as they are evaluated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>Query used for matching rules. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of rules. </dd></dl>

<p>Implemented in <a class="el" href="classusbguard_1_1IPCClient.html#a4d6824e6450a2d316cf16825d9b4c5ce">usbguard::IPCClient</a>.</p>

</div>
</div>
<a id="a671eed8ebea79f8f6f9a6dfc39e26253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a671eed8ebea79f8f6f9a6dfc39e26253">&#9670;&nbsp;</a></span>PropertyParameterChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void usbguard::Interface::PropertyParameterChanged </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value_old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value_new</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify about a change of a property parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Policy name. </td></tr>
    <tr><td class="paramname">value_old</td><td>Previous policy value. </td></tr>
    <tr><td class="paramname">value_new</td><td>Current policy value. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classusbguard_1_1IPCServer.html#a4dad21f0847b381b63dbfebadda20281">usbguard::IPCServer</a>, and <a class="el" href="classusbguard_1_1IPCClient.html#a23891d3007d194c63baef67164672ded">usbguard::IPCClient</a>.</p>

</div>
</div>
<a id="a7a369e492afb793778a748182c78501d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a369e492afb793778a748182c78501d">&#9670;&nbsp;</a></span>removeRule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void usbguard::Interface::removeRule </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a rule from the current policy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The rule ID of the rule to be removed. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classusbguard_1_1IPCClient.html#a0cd5109e070a4d1a7e7fde9ffa698691">usbguard::IPCClient</a>.</p>

</div>
</div>
<a id="a38d65c802d84b9ce6bb979fd5690d1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38d65c802d84b9ce6bb979fd5690d1ee">&#9670;&nbsp;</a></span>setParameter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string usbguard::Interface::setParameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set value of a runtime parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of runtime parameter. </td></tr>
    <tr><td class="paramname">value</td><td>Value of runtime parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Previous value of runtime parameter. </dd></dl>

<p>Implemented in <a class="el" href="classusbguard_1_1IPCClient.html#a55ccb1a393f7c1298b03eb7de8573e6d">usbguard::IPCClient</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Interface_8hpp_source.html">Interface.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
